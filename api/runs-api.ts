/* tslint:disable */
/* eslint-disable */
/**
 * pollination-server
 * Pollination Server OpenAPI Definition
 *
 * The version of the OpenAPI document: 0.21.0
 * Contact: info@pollination.cloud
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FileMeta } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { Run } from '../models';
// @ts-ignore
import { RunList } from '../models';
// @ts-ignore
import { RunResultList } from '../models';
// @ts-ignore
import { RunStatusEnum } from '../models';
// @ts-ignore
import { StepList } from '../models';
// @ts-ignore
import { StepStatusEnum } from '../models';
/**
 * RunsApi - axios parameter creator
 * @export
 */
export const RunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stop a run.
         * @summary Cancel a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRun: async (owner: string, name: string, runId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling cancelRun.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling cancelRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling cancelRun.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/cancel`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a download link for an artifact in a run folder
         * @summary Download an artifact from the run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} [path] The path to an file within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunArtifact: async (owner: string, name: string, runId: string, path?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling downloadRunArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling downloadRunArtifact.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling downloadRunArtifact.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/artifacts/download`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a run.
         * @summary Get a Run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (owner: string, name: string, runId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRun.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get run output by name
         * @summary Get run output by name
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} outputName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunOutput: async (owner: string, name: string, runId: string, outputName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunOutput.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRunOutput.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRunOutput.');
            }
            // verify required parameter 'outputName' is not null or undefined
            if (outputName === null || outputName === undefined) {
                throw new RequiredError('outputName','Required parameter outputName was null or undefined when calling getRunOutput.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/outputs/{output_name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"output_name"}}`, encodeURIComponent(String(outputName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * get run step logs
         * @summary Get the logs of a specific step of the run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStepLogs: async (owner: string, name: string, runId: string, stepId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStepLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRunStepLogs.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRunStepLogs.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new RequiredError('stepId','Required parameter stepId was null or undefined when calling getRunStepLogs.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/steps/{step_id}/logs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * list run steps
         * @summary Query the steps of a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {StepStatusEnum} [status] 
         * @param {Array<string>} [stepId] 
         * @param {string} [untilGeneration] 
         * @param {string} [sinceGeneration] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSteps: async (owner: string, name: string, runId: string, status?: StepStatusEnum, stepId?: Array<string>, untilGeneration?: string, sinceGeneration?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunSteps.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRunSteps.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRunSteps.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/steps`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (stepId) {
                localVarQueryParameter['step_id'] = stepId;
            }

            if (untilGeneration !== undefined) {
                localVarQueryParameter['until_generation'] = untilGeneration;
            }

            if (sinceGeneration !== undefined) {
                localVarQueryParameter['since_generation'] = sinceGeneration;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of artifacts in a run folder
         * @summary List artifacts in a run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {Array<string>} [path] The path to an file within a project folder
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunArtifacts: async (owner: string, name: string, runId: string, path?: Array<string>, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunArtifacts.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listRunArtifacts.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling listRunArtifacts.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs/{run_id}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of runs.
         * @summary List runs
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listRuns.');
            }
            const localVarPath = `/projects/{owner}/{name}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (jobId) {
                localVarQueryParameter['job_id'] = jobId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of run results.
         * @summary Query run results
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResults: async (owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queryResults.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queryResults.');
            }
            const localVarPath = `/projects/{owner}/{name}/results`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-pollination-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-pollination-token"] = localVarApiKeyValue;
            }

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (jobId) {
                localVarQueryParameter['job_id'] = jobId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 * @export
 */
export const RunsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Stop a run.
         * @summary Cancel a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelRun(owner: string, name: string, runId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).cancelRun(owner, name, runId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a download link for an artifact in a run folder
         * @summary Download an artifact from the run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} [path] The path to an file within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRunArtifact(owner: string, name: string, runId: string, path?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).downloadRunArtifact(owner, name, runId, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a run.
         * @summary Get a Run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(owner: string, name: string, runId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).getRun(owner, name, runId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get run output by name
         * @summary Get run output by name
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} outputName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunOutput(owner: string, name: string, runId: string, outputName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).getRunOutput(owner, name, runId, outputName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get run step logs
         * @summary Get the logs of a specific step of the run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStepLogs(owner: string, name: string, runId: string, stepId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).getRunStepLogs(owner, name, runId, stepId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * list run steps
         * @summary Query the steps of a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {StepStatusEnum} [status] 
         * @param {Array<string>} [stepId] 
         * @param {string} [untilGeneration] 
         * @param {string} [sinceGeneration] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunSteps(owner: string, name: string, runId: string, status?: StepStatusEnum, stepId?: Array<string>, untilGeneration?: string, sinceGeneration?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepList>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).getRunSteps(owner, name, runId, status, stepId, untilGeneration, sinceGeneration, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of artifacts in a run folder
         * @summary List artifacts in a run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {Array<string>} [path] The path to an file within a project folder
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunArtifacts(owner: string, name: string, runId: string, path?: Array<string>, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileMeta>>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).listRunArtifacts(owner, name, runId, path, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of runs.
         * @summary List runs
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunList>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).listRuns(owner, name, jobId, status, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of run results.
         * @summary Query run results
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryResults(owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunResultList>> {
            const localVarAxiosArgs = await RunsApiAxiosParamCreator(configuration).queryResults(owner, name, jobId, status, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RunsApi - factory interface
 * @export
 */
export const RunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Stop a run.
         * @summary Cancel a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRun(owner: string, name: string, runId: string, options?: any): AxiosPromise<any> {
            return RunsApiFp(configuration).cancelRun(owner, name, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a download link for an artifact in a run folder
         * @summary Download an artifact from the run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} [path] The path to an file within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunArtifact(owner: string, name: string, runId: string, path?: string, options?: any): AxiosPromise<any> {
            return RunsApiFp(configuration).downloadRunArtifact(owner, name, runId, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a run.
         * @summary Get a Run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, name: string, runId: string, options?: any): AxiosPromise<Run> {
            return RunsApiFp(configuration).getRun(owner, name, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * get run output by name
         * @summary Get run output by name
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} outputName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunOutput(owner: string, name: string, runId: string, outputName: string, options?: any): AxiosPromise<any> {
            return RunsApiFp(configuration).getRunOutput(owner, name, runId, outputName, options).then((request) => request(axios, basePath));
        },
        /**
         * get run step logs
         * @summary Get the logs of a specific step of the run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStepLogs(owner: string, name: string, runId: string, stepId: string, options?: any): AxiosPromise<string> {
            return RunsApiFp(configuration).getRunStepLogs(owner, name, runId, stepId, options).then((request) => request(axios, basePath));
        },
        /**
         * list run steps
         * @summary Query the steps of a run
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {StepStatusEnum} [status] 
         * @param {Array<string>} [stepId] 
         * @param {string} [untilGeneration] 
         * @param {string} [sinceGeneration] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSteps(owner: string, name: string, runId: string, status?: StepStatusEnum, stepId?: Array<string>, untilGeneration?: string, sinceGeneration?: string, page?: number, perPage?: number, options?: any): AxiosPromise<StepList> {
            return RunsApiFp(configuration).getRunSteps(owner, name, runId, status, stepId, untilGeneration, sinceGeneration, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of artifacts in a run folder
         * @summary List artifacts in a run folder
         * @param {string} owner 
         * @param {string} name 
         * @param {string} runId 
         * @param {Array<string>} [path] The path to an file within a project folder
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunArtifacts(owner: string, name: string, runId: string, path?: Array<string>, page?: number, perPage?: number, options?: any): AxiosPromise<Array<FileMeta>> {
            return RunsApiFp(configuration).listRunArtifacts(owner, name, runId, path, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of runs.
         * @summary List runs
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options?: any): AxiosPromise<RunList> {
            return RunsApiFp(configuration).listRuns(owner, name, jobId, status, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of run results.
         * @summary Query run results
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [jobId] 
         * @param {RunStatusEnum} [status] 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResults(owner: string, name: string, jobId?: Array<string>, status?: RunStatusEnum, page?: number, perPage?: number, options?: any): AxiosPromise<RunResultList> {
            return RunsApiFp(configuration).queryResults(owner, name, jobId, status, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelRun operation in RunsApi.
 * @export
 * @interface RunsApiCancelRunRequest
 */
export interface RunsApiCancelRunRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiCancelRun
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiCancelRun
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiCancelRun
     */
    readonly runId: string
}

/**
 * Request parameters for downloadRunArtifact operation in RunsApi.
 * @export
 * @interface RunsApiDownloadRunArtifactRequest
 */
export interface RunsApiDownloadRunArtifactRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiDownloadRunArtifact
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiDownloadRunArtifact
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiDownloadRunArtifact
     */
    readonly runId: string

    /**
     * The path to an file within a project folder
     * @type {string}
     * @memberof RunsApiDownloadRunArtifact
     */
    readonly path?: string
}

/**
 * Request parameters for getRun operation in RunsApi.
 * @export
 * @interface RunsApiGetRunRequest
 */
export interface RunsApiGetRunRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRun
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRun
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRun
     */
    readonly runId: string
}

/**
 * Request parameters for getRunOutput operation in RunsApi.
 * @export
 * @interface RunsApiGetRunOutputRequest
 */
export interface RunsApiGetRunOutputRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunOutput
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunOutput
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunOutput
     */
    readonly runId: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunOutput
     */
    readonly outputName: string
}

/**
 * Request parameters for getRunStepLogs operation in RunsApi.
 * @export
 * @interface RunsApiGetRunStepLogsRequest
 */
export interface RunsApiGetRunStepLogsRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunStepLogs
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunStepLogs
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunStepLogs
     */
    readonly runId: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunStepLogs
     */
    readonly stepId: string
}

/**
 * Request parameters for getRunSteps operation in RunsApi.
 * @export
 * @interface RunsApiGetRunStepsRequest
 */
export interface RunsApiGetRunStepsRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunSteps
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunSteps
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunSteps
     */
    readonly runId: string

    /**
     * 
     * @type {StepStatusEnum}
     * @memberof RunsApiGetRunSteps
     */
    readonly status?: StepStatusEnum

    /**
     * 
     * @type {Array<string>}
     * @memberof RunsApiGetRunSteps
     */
    readonly stepId?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunSteps
     */
    readonly untilGeneration?: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiGetRunSteps
     */
    readonly sinceGeneration?: string

    /**
     * Page number starting from 1
     * @type {number}
     * @memberof RunsApiGetRunSteps
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof RunsApiGetRunSteps
     */
    readonly perPage?: number
}

/**
 * Request parameters for listRunArtifacts operation in RunsApi.
 * @export
 * @interface RunsApiListRunArtifactsRequest
 */
export interface RunsApiListRunArtifactsRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiListRunArtifacts
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiListRunArtifacts
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiListRunArtifacts
     */
    readonly runId: string

    /**
     * The path to an file within a project folder
     * @type {Array<string>}
     * @memberof RunsApiListRunArtifacts
     */
    readonly path?: Array<string>

    /**
     * Page number starting from 1
     * @type {number}
     * @memberof RunsApiListRunArtifacts
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof RunsApiListRunArtifacts
     */
    readonly perPage?: number
}

/**
 * Request parameters for listRuns operation in RunsApi.
 * @export
 * @interface RunsApiListRunsRequest
 */
export interface RunsApiListRunsRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiListRuns
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiListRuns
     */
    readonly name: string

    /**
     * 
     * @type {Array<string>}
     * @memberof RunsApiListRuns
     */
    readonly jobId?: Array<string>

    /**
     * 
     * @type {RunStatusEnum}
     * @memberof RunsApiListRuns
     */
    readonly status?: RunStatusEnum

    /**
     * Page number starting from 1
     * @type {number}
     * @memberof RunsApiListRuns
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof RunsApiListRuns
     */
    readonly perPage?: number
}

/**
 * Request parameters for queryResults operation in RunsApi.
 * @export
 * @interface RunsApiQueryResultsRequest
 */
export interface RunsApiQueryResultsRequest {
    /**
     * 
     * @type {string}
     * @memberof RunsApiQueryResults
     */
    readonly owner: string

    /**
     * 
     * @type {string}
     * @memberof RunsApiQueryResults
     */
    readonly name: string

    /**
     * 
     * @type {Array<string>}
     * @memberof RunsApiQueryResults
     */
    readonly jobId?: Array<string>

    /**
     * 
     * @type {RunStatusEnum}
     * @memberof RunsApiQueryResults
     */
    readonly status?: RunStatusEnum

    /**
     * Page number starting from 1
     * @type {number}
     * @memberof RunsApiQueryResults
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof RunsApiQueryResults
     */
    readonly perPage?: number
}

/**
 * RunsApi - object-oriented interface
 * @export
 * @class RunsApi
 * @extends {BaseAPI}
 */
export class RunsApi extends BaseAPI {
    /**
     * Stop a run.
     * @summary Cancel a run
     * @param {RunsApiCancelRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public cancelRun(requestParameters: RunsApiCancelRunRequest, options?: any) {
        return RunsApiFp(this.configuration).cancelRun(requestParameters.owner, requestParameters.name, requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a download link for an artifact in a run folder
     * @summary Download an artifact from the run folder
     * @param {RunsApiDownloadRunArtifactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public downloadRunArtifact(requestParameters: RunsApiDownloadRunArtifactRequest, options?: any) {
        return RunsApiFp(this.configuration).downloadRunArtifact(requestParameters.owner, requestParameters.name, requestParameters.runId, requestParameters.path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a run.
     * @summary Get a Run
     * @param {RunsApiGetRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRun(requestParameters: RunsApiGetRunRequest, options?: any) {
        return RunsApiFp(this.configuration).getRun(requestParameters.owner, requestParameters.name, requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get run output by name
     * @summary Get run output by name
     * @param {RunsApiGetRunOutputRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRunOutput(requestParameters: RunsApiGetRunOutputRequest, options?: any) {
        return RunsApiFp(this.configuration).getRunOutput(requestParameters.owner, requestParameters.name, requestParameters.runId, requestParameters.outputName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get run step logs
     * @summary Get the logs of a specific step of the run
     * @param {RunsApiGetRunStepLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRunStepLogs(requestParameters: RunsApiGetRunStepLogsRequest, options?: any) {
        return RunsApiFp(this.configuration).getRunStepLogs(requestParameters.owner, requestParameters.name, requestParameters.runId, requestParameters.stepId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list run steps
     * @summary Query the steps of a run
     * @param {RunsApiGetRunStepsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRunSteps(requestParameters: RunsApiGetRunStepsRequest, options?: any) {
        return RunsApiFp(this.configuration).getRunSteps(requestParameters.owner, requestParameters.name, requestParameters.runId, requestParameters.status, requestParameters.stepId, requestParameters.untilGeneration, requestParameters.sinceGeneration, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of artifacts in a run folder
     * @summary List artifacts in a run folder
     * @param {RunsApiListRunArtifactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public listRunArtifacts(requestParameters: RunsApiListRunArtifactsRequest, options?: any) {
        return RunsApiFp(this.configuration).listRunArtifacts(requestParameters.owner, requestParameters.name, requestParameters.runId, requestParameters.path, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of runs.
     * @summary List runs
     * @param {RunsApiListRunsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public listRuns(requestParameters: RunsApiListRunsRequest, options?: any) {
        return RunsApiFp(this.configuration).listRuns(requestParameters.owner, requestParameters.name, requestParameters.jobId, requestParameters.status, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of run results.
     * @summary Query run results
     * @param {RunsApiQueryResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public queryResults(requestParameters: RunsApiQueryResultsRequest, options?: any) {
        return RunsApiFp(this.configuration).queryResults(requestParameters.owner, requestParameters.name, requestParameters.jobId, requestParameters.status, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
