// tslint:disable
/**
 * Pollination Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.5.23
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Accepted request response.
 * @export
 * @interface Accepted
 */
export interface Accepted {
    /**
     * Url to access the requested resource.
     * @type {string}
     * @memberof Accepted
     */
    url: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof Accepted
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface AccountPublic
 */
export interface AccountPublic {
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    name: string;
}
/**
 * A workflow Artifact Argument
 * @export
 * @interface ArgumentArtifact
 */
export interface ArgumentArtifact {
    /**
     * The name of the artifact
     * @type {string}
     * @memberof ArgumentArtifact
     */
    name: string;
    /**
     * 
     * @type {object}
     * @memberof ArgumentArtifact
     */
    source: object;
}
/**
 * A workflow Parameter Argument
 * @export
 * @interface ArgumentParameter
 */
export interface ArgumentParameter {
    /**
     * The name of the parameter
     * @type {string}
     * @memberof ArgumentParameter
     */
    name: string;
    /**
     * The value of the parameter
     * @type {string}
     * @memberof ArgumentParameter
     */
    value: string;
}
/**
 * Workflow Arguments
 * @export
 * @interface Arguments
 */
export interface Arguments {
    /**
     * A list of input parameters
     * @type {Array<ArgumentParameter>}
     * @memberof Arguments
     */
    parameters?: Array<ArgumentParameter>;
    /**
     * A list of input artifacts
     * @type {Array<ArgumentArtifact>}
     * @memberof Arguments
     */
    artifacts?: Array<ArgumentArtifact>;
}
/**
 * 
 * @export
 * @interface BodyPostOperatorRegistriesOwnerOperatorsPost
 */
export interface BodyPostOperatorRegistriesOwnerOperatorsPost {
    /**
     * 
     * @type {any}
     * @memberof BodyPostOperatorRegistriesOwnerOperatorsPost
     */
    _package: any;
}
/**
 * 
 * @export
 * @interface BodyPostRecipeRegistriesOwnerRecipesPost
 */
export interface BodyPostRecipeRegistriesOwnerRecipesPost {
    /**
     * 
     * @type {any}
     * @memberof BodyPostRecipeRegistriesOwnerRecipesPost
     */
    _package: any;
}
/**
 * Operator configuration.  The config is used to schedule functions on a desktop or in other contexts (ie: Docker).
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * The configuration to use this operator in a docker container
     * @type {DockerConfig}
     * @memberof Config
     */
    docker: DockerConfig;
    /**
     * The configuration to use this operator locally
     * @type {object}
     * @memberof Config
     */
    local?: object;
}
/**
 * 
 * @export
 * @interface CreateOrgDto
 */
export interface CreateOrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof CreateOrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof CreateOrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof CreateOrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof CreateOrgDto
     */
    description?: string;
    /**
     * The unique name of the org in small case without spaces
     * @type {string}
     * @memberof CreateOrgDto
     */
    accountName: string;
}
/**
 * 
 * @export
 * @interface CreateTokenDto
 */
export interface CreateTokenDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    tokenName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    password: string;
}
/**
 * Content for created response.
 * @export
 * @interface CreatedContent
 */
export interface CreatedContent {
    /**
     * Id for the newly created resource.
     * @type {string}
     * @memberof CreatedContent
     */
    id: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof CreatedContent
     */
    message?: string;
}
/**
 * A Directed Acyclic Graph containing a list of tasks.
 * @export
 * @interface DAG
 */
export interface DAG {
    /**
     * A unique name for this dag.
     * @type {string}
     * @memberof DAG
     */
    name: string;
    /**
     * Inputs for the DAG.
     * @type {DAGInputs}
     * @memberof DAG
     */
    inputs?: DAGInputs;
    /**
     * Stop scheduling new steps, as soon as it detects that one of the DAG nodes is failed. Default is True.
     * @type {boolean}
     * @memberof DAG
     */
    failFast?: boolean;
    /**
     * Tasks are a list of DAG steps
     * @type {Array<DAGTask>}
     * @memberof DAG
     */
    tasks: Array<DAGTask>;
    /**
     * Outputs of the DAG that can be used by other DAGs
     * @type {DAGOutputs}
     * @memberof DAG
     */
    outputs?: DAGOutputs;
}
/**
 * An artifact used within the DAG.
 * @export
 * @interface DAGInputArtifact
 */
export interface DAGInputArtifact {
    /**
     * The name of the artifact within the scope of the DAG
     * @type {string}
     * @memberof DAGInputArtifact
     */
    name: string;
    /**
     * Optional description for the input artifact
     * @type {string}
     * @memberof DAGInputArtifact
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof DAGInputArtifact
     */
    _default?: object;
    /**
     * Whether this value must be specified in a task argument.
     * @type {boolean}
     * @memberof DAGInputArtifact
     */
    required?: boolean;
}
/**
 * An input parameter used within the DAG.
 * @export
 * @interface DAGInputParameter
 */
export interface DAGInputParameter {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs.
     * @type {string}
     * @memberof DAGInputParameter
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {string}
     * @memberof DAGInputParameter
     */
    _default?: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof DAGInputParameter
     */
    description?: string;
    /**
     * Whether this value must be specified in a task argument.
     * @type {boolean}
     * @memberof DAGInputParameter
     */
    required?: boolean;
}
/**
 * Inputs of a DAG.
 * @export
 * @interface DAGInputs
 */
export interface DAGInputs {
    /**
     * A list of parameters the DAG will use as input values
     * @type {Array<DAGInputParameter>}
     * @memberof DAGInputs
     */
    parameters?: Array<DAGInputParameter>;
    /**
     * A list of artifacts the DAG will use
     * @type {Array<DAGInputArtifact>}
     * @memberof DAGInputs
     */
    artifacts?: Array<DAGInputArtifact>;
}
/**
 * An artifact sourced from within the DAG that is exposed as an output
 * @export
 * @interface DAGOutputArtifact
 */
export interface DAGOutputArtifact {
    /**
     * The name of the output variable
     * @type {string}
     * @memberof DAGOutputArtifact
     */
    name: string;
    /**
     * The task reference to pull this output variable from. Note, this must be an output variable.
     * @type {TaskArtifactReference}
     * @memberof DAGOutputArtifact
     */
    from: TaskArtifactReference;
}
/**
 * A parameter sourced from within the DAG that is exposed as an output.
 * @export
 * @interface DAGOutputParameter
 */
export interface DAGOutputParameter {
    /**
     * The name of the output variable
     * @type {string}
     * @memberof DAGOutputParameter
     */
    name: string;
    /**
     * The task reference to pull this output variable from. Note, this must be an output variable.
     * @type {TaskParameterReference}
     * @memberof DAGOutputParameter
     */
    from: TaskParameterReference;
}
/**
 * Artifacts and Parameters exposed by the DAG
 * @export
 * @interface DAGOutputs
 */
export interface DAGOutputs {
    /**
     * A list of output parameters exposed by this DAG
     * @type {Array<DAGOutputParameter>}
     * @memberof DAGOutputs
     */
    parameters?: Array<DAGOutputParameter>;
    /**
     * A list of output artifacts exposed by this DAG
     * @type {Array<DAGOutputArtifact>}
     * @memberof DAGOutputs
     */
    artifacts?: Array<DAGOutputArtifact>;
}
/**
 * The instance of a function template matched with DAG inputs and outputs.
 * @export
 * @interface DAGTask
 */
export interface DAGTask {
    /**
     * Name for this step. It must be unique in DAG.
     * @type {string}
     * @memberof DAGTask
     */
    name: string;
    /**
     * Template name.
     * @type {string}
     * @memberof DAGTask
     */
    template: string;
    /**
     * The input arguments for this task
     * @type {DAGTaskArgument}
     * @memberof DAGTask
     */
    arguments?: DAGTaskArgument;
    /**
     * Dependencies are name of other DAG steps which this depends on.
     * @type {Array<string>}
     * @memberof DAGTask
     */
    dependencies?: Array<string>;
    /**
     * List of inputs to loop over.
     * @type {DAGTaskLoop}
     * @memberof DAGTask
     */
    loop?: DAGTaskLoop;
    /**
     * A path relative to the current folder context where artifacts should be saved. This is useful when performing a loop or invoking another workflow and wanting to save results in a specific folder.
     * @type {string}
     * @memberof DAGTask
     */
    subFolder?: string;
    /**
     * The outputs of this task
     * @type {DAGTaskOutputs}
     * @memberof DAGTask
     */
    outputs?: DAGTaskOutputs;
}
/**
 * DAG task argument.  These arguments should match the inputs from the template referenced in the task.
 * @export
 * @interface DAGTaskArgument
 */
export interface DAGTaskArgument {
    /**
     * A list of input parameters to pass to the task
     * @type {Array<DAGTaskParameterArgument>}
     * @memberof DAGTaskArgument
     */
    parameters?: Array<DAGTaskParameterArgument>;
    /**
     * A list of input artifacts to pass to the task
     * @type {Array<DAGTaskArtifactArgument>}
     * @memberof DAGTaskArgument
     */
    artifacts?: Array<DAGTaskArtifactArgument>;
}
/**
 * Input argument for a DAG task.  The name must correspond to an input artifact from the template function the task refers to.
 * @export
 * @interface DAGTaskArtifactArgument
 */
export interface DAGTaskArtifactArgument {
    /**
     * Name of the argument variable
     * @type {string}
     * @memberof DAGTaskArtifactArgument
     */
    name: string;
    /**
     * 
     * @type {object}
     * @memberof DAGTaskArtifactArgument
     */
    from: object;
    /**
     * Specify this value if your source artifact is a repository and you want to source an artifact from within that directory.
     * @type {string}
     * @memberof DAGTaskArtifactArgument
     */
    subpath?: string;
}
/**
 * Loop configuration for the task.  This will run the template provided multiple times and in parallel relative to an input or task parameter which should be a list.
 * @export
 * @interface DAGTaskLoop
 */
export interface DAGTaskLoop {
    /**
     * 
     * @type {object}
     * @memberof DAGTaskLoop
     */
    from?: object;
    /**
     * A list of values or JSON objects to loop over.
     * @type {Array<object>}
     * @memberof DAGTaskLoop
     */
    value?: Array<object>;
    /**
     * Parameters to control some loop behavior for this task
     * @type {LoopControl}
     * @memberof DAGTaskLoop
     */
    control?: LoopControl;
}
/**
 * Output artifact for a DAG task.  The name must correspond to an output artifact from the template function the task refers to.
 * @export
 * @interface DAGTaskOutputArtifact
 */
export interface DAGTaskOutputArtifact {
    /**
     * The name of the output variable
     * @type {string}
     * @memberof DAGTaskOutputArtifact
     */
    name: string;
    /**
     * The path where the artifact should be saved relative to the DAG folder.
     * @type {string}
     * @memberof DAGTaskOutputArtifact
     */
    path?: string;
}
/**
 * Output parameter for a DAG task.  The name must correspond to an output parameter from the template function the task refers to.
 * @export
 * @interface DAGTaskOutputParameter
 */
export interface DAGTaskOutputParameter {
    /**
     * The name of the output variable
     * @type {string}
     * @memberof DAGTaskOutputParameter
     */
    name: string;
}
/**
 * These outputs should match the outputs from the template referenced in the task
 * @export
 * @interface DAGTaskOutputs
 */
export interface DAGTaskOutputs {
    /**
     * A list of output parameters to expose from the task
     * @type {Array<DAGTaskOutputParameter>}
     * @memberof DAGTaskOutputs
     */
    parameters?: Array<DAGTaskOutputParameter>;
    /**
     * A list of output artifacts to expose from the task
     * @type {Array<DAGTaskOutputArtifact>}
     * @memberof DAGTaskOutputs
     */
    artifacts?: Array<DAGTaskOutputArtifact>;
}
/**
 * Input argument for a DAG task.  The name must correspond to an input parameter from the template function the task refers to.
 * @export
 * @interface DAGTaskParameterArgument
 */
export interface DAGTaskParameterArgument {
    /**
     * Name of the argument variable
     * @type {string}
     * @memberof DAGTaskParameterArgument
     */
    name: string;
    /**
     * 
     * @type {object}
     * @memberof DAGTaskParameterArgument
     */
    from?: object;
    /**
     * The fixed value for this task argument
     * @type {string}
     * @memberof DAGTaskParameterArgument
     */
    value?: string;
}
/**
 * Configuration to fetch a Recipe or Operator that another Recipe depends on.
 * @export
 * @interface Dependency
 */
export interface Dependency {
    /**
     * The type of dependency
     * @type {string}
     * @memberof Dependency
     */
    type: DependencyTypeEnum;
    /**
     * Workflow name. This name should be unique among all the resources in your resource. Use an alias if this is not the case.
     * @type {string}
     * @memberof Dependency
     */
    name: string;
    /**
     * The digest hash of the dependency when retrieved from its source. This is locked when the resource dependencies are downloaded.
     * @type {string}
     * @memberof Dependency
     */
    hash?: string;
    /**
     * An optional alias to refer to this dependency. Useful if the name is already used somewhere else.
     * @type {string}
     * @memberof Dependency
     */
    alias?: string;
    /**
     * Tag of the resource.
     * @type {string}
     * @memberof Dependency
     */
    tag: string;
    /**
     * URL to a repository where this resource can be found.
     * @type {string}
     * @memberof Dependency
     */
    source: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DependencyTypeEnum {
    Recipe = 'recipe',
    Operator = 'operator'
}

/**
 * Operator Configuration to run in a Docker container
 * @export
 * @interface DockerConfig
 */
export interface DockerConfig {
    /**
     * Docker image name. Must include tag.
     * @type {string}
     * @memberof DockerConfig
     */
    image: string;
    /**
     * The container registry URLs that this container should be pulled from. Will default to Dockerhub if none is specified.
     * @type {string}
     * @memberof DockerConfig
     */
    registry?: string;
    /**
     * The working directory the entrypoint command of the container runsin. This is used to determine where to load artifacts when running in the container.
     * @type {string}
     * @memberof DockerConfig
     */
    workdir: string;
}
/**
 * 
 * @export
 * @interface EmailRequest
 */
export interface EmailRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface FileMeta
 */
export interface FileMeta {
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    fileName: string;
    /**
     * 
     * @type {Date}
     * @memberof FileMeta
     */
    lastModified?: Date;
    /**
     * 
     * @type {number}
     * @memberof FileMeta
     */
    size?: number;
}
/**
 * A Function with a single command
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * Function name. Must be unique within an operator.
     * @type {string}
     * @memberof Function
     */
    name: string;
    /**
     * Function description. A short human readable description for this function.
     * @type {string}
     * @memberof Function
     */
    description?: string;
    /**
     * Input arguments for this function.
     * @type {FunctionInputs}
     * @memberof Function
     */
    inputs?: FunctionInputs;
    /**
     * Full shell command for this function. Each function accepts only one command. The command will be executed as a shell command in operator. For running several commands after each other use && between the commands or pipe data from one to another using |
     * @type {string}
     * @memberof Function
     */
    command: string;
    /**
     * List of output arguments.
     * @type {FunctionOutputs}
     * @memberof Function
     */
    outputs?: FunctionOutputs;
}
/**
 * A Function Artifact object  This indicates the path within the function context at which a certain file or folder (ie: artifact) can be found.
 * @export
 * @interface FunctionArtifact
 */
export interface FunctionArtifact {
    /**
     * Name of the artifact. Must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof FunctionArtifact
     */
    name: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof FunctionArtifact
     */
    description?: string;
    /**
     * Path to the artifact relative to the working directory where the command is executed.
     * @type {string}
     * @memberof FunctionArtifact
     */
    path: string;
}
/**
 * The Inputs of a Function
 * @export
 * @interface FunctionInputs
 */
export interface FunctionInputs {
    /**
     * 
     * @type {Array<FunctionParameterIn>}
     * @memberof FunctionInputs
     */
    parameters?: Array<FunctionParameterIn>;
    /**
     * 
     * @type {Array<FunctionArtifact>}
     * @memberof FunctionInputs
     */
    artifacts?: Array<FunctionArtifact>;
}
/**
 * The Outputs of a Function
 * @export
 * @interface FunctionOutputs
 */
export interface FunctionOutputs {
    /**
     * 
     * @type {Array<FunctionParameterOut>}
     * @memberof FunctionOutputs
     */
    parameters?: Array<FunctionParameterOut>;
    /**
     * 
     * @type {Array<FunctionArtifact>}
     * @memberof FunctionOutputs
     */
    artifacts?: Array<FunctionArtifact>;
}
/**
 * A Function Parameter  Parameter indicate a passed string parameter to a service template with an optional default value.
 * @export
 * @interface FunctionParameterIn
 */
export interface FunctionParameterIn {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs.
     * @type {string}
     * @memberof FunctionParameterIn
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {string}
     * @memberof FunctionParameterIn
     */
    _default?: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof FunctionParameterIn
     */
    description?: string;
    /**
     * Whether this value must be specified in a task argument.
     * @type {boolean}
     * @memberof FunctionParameterIn
     */
    required?: boolean;
}
/**
 * A Function Artifact object  This indicates the path within the function context at which a certain file or folder (ie: artifact) can be found.
 * @export
 * @interface FunctionParameterOut
 */
export interface FunctionParameterOut {
    /**
     * Name of the artifact. Must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof FunctionParameterOut
     */
    name: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof FunctionParameterOut
     */
    description?: string;
    /**
     * Path to the artifact relative to the working directory where the command is executed.
     * @type {string}
     * @memberof FunctionParameterOut
     */
    path: string;
}
/**
 * HTTPSource  A web HTTP to an FTP server or an API for example.
 * @export
 * @interface HTTPSource
 */
export interface HTTPSource {
    /**
     * 
     * @type {string}
     * @memberof HTTPSource
     */
    type: HTTPSourceTypeEnum;
    /**
     * For a HTTP endpoint this can be http://climate.onebuilding.org.
     * @type {string}
     * @memberof HTTPSource
     */
    url: string;
}

/**
    * @export
    * @enum {string}
    */
export enum HTTPSourceTypeEnum {
    Http = 'http'
}

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * An Input Artifact Reference
 * @export
 * @interface InputArtifactReference
 */
export interface InputArtifactReference {
    /**
     * 
     * @type {string}
     * @memberof InputArtifactReference
     */
    type?: InputArtifactReferenceTypeEnum;
    /**
     * The name of the DAG input variable
     * @type {string}
     * @memberof InputArtifactReference
     */
    variable: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InputArtifactReferenceTypeEnum {
    Inputs = 'inputs'
}

/**
 * An Input Parameter Reference
 * @export
 * @interface InputParameterReference
 */
export interface InputParameterReference {
    /**
     * 
     * @type {string}
     * @memberof InputParameterReference
     */
    type?: InputParameterReferenceTypeEnum;
    /**
     * The name of the DAG input variable
     * @type {string}
     * @memberof InputParameterReference
     */
    variable: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InputParameterReferenceTypeEnum {
    Inputs = 'inputs'
}

/**
 * An Item Parameter Reference
 * @export
 * @interface ItemParameterReference
 */
export interface ItemParameterReference {
    /**
     * 
     * @type {string}
     * @memberof ItemParameterReference
     */
    type?: ItemParameterReferenceTypeEnum;
    /**
     * The name of the looped item variable (use dot notation for nested json values)
     * @type {string}
     * @memberof ItemParameterReference
     */
    variable?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemParameterReferenceTypeEnum {
    Item = 'item'
}

/**
 * 
 * @export
 * @interface KeyRequest
 */
export interface KeyRequest {
    /**
     * 
     * @type {string}
     * @memberof KeyRequest
     */
    key: string;
}
/**
 * License information for the Recipe
 * @export
 * @interface License
 */
export interface License {
    /**
     * The license name used for the recipe.
     * @type {string}
     * @memberof License
     */
    name: string;
    /**
     * A URL to the license used for the recipe.
     * @type {string}
     * @memberof License
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * An api token generated by calling the POST /user/tokens endpoint
     * @type {string}
     * @memberof LoginDto
     */
    apiToken: string;
}
/**
 * 
 * @export
 * @interface LoginToken
 */
export interface LoginToken {
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    idToken?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    tokenType: string;
    /**
     * 
     * @type {number}
     * @memberof LoginToken
     */
    expiresIn: number;
}
/**
 * Loop Control
 * @export
 * @interface LoopControl
 */
export interface LoopControl {
    /**
     * The loop control key determines how parameters and artifacts from a looped task can be identified
     * @type {string}
     * @memberof LoopControl
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface NewOperatorPackage
 */
export interface NewOperatorPackage {
    /**
     * The Operator manifest to be created
     * @type {Operator}
     * @memberof NewOperatorPackage
     */
    manifest: Operator;
    /**
     * The README file to attach to this package
     * @type {string}
     * @memberof NewOperatorPackage
     */
    readme?: string;
    /**
     * The license file to attach to this package
     * @type {string}
     * @memberof NewOperatorPackage
     */
    license?: string;
}
/**
 * 
 * @export
 * @interface NewRecipePackage
 */
export interface NewRecipePackage {
    /**
     * The Recipe manifest to be created
     * @type {Recipe}
     * @memberof NewRecipePackage
     */
    manifest: Recipe;
    /**
     * The README file to attach to this package
     * @type {string}
     * @memberof NewRecipePackage
     */
    readme?: string;
    /**
     * The license file to attach to this package
     * @type {string}
     * @memberof NewRecipePackage
     */
    license?: string;
}
/**
 * 
 * @export
 * @interface NewRepositoryDto
 */
export interface NewRepositoryDto {
    /**
     * Whether or not a repository is publicly viewable
     * @type {boolean}
     * @memberof NewRepositoryDto
     */
    _public?: boolean;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof NewRepositoryDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof NewRepositoryDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof NewRepositoryDto
     */
    icon?: string;
    /**
     * The name of the repository
     * @type {string}
     * @memberof NewRepositoryDto
     */
    name: string;
}
/**
 * A Queenbee Operator.  An Operator contains runtime configuration for a Command Line Interface (CLI) and a list of functions that can be executed using this CLI tool.
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * The Operator metadata information
     * @type {QueenbeeOperatorMetadataMetaData}
     * @memberof Operator
     */
    metadata: QueenbeeOperatorMetadataMetaData;
    /**
     * The configuration information to run this operator
     * @type {Config}
     * @memberof Operator
     */
    config: Config;
    /**
     * List of Operator functions
     * @type {Array<Function>}
     * @memberof Operator
     */
    functions: Array<Function>;
}
/**
 * A version of an Operator
 * @export
 * @interface OperatorVersion
 */
export interface OperatorVersion {
    /**
     * Operator name. This name should be unique among all the operators in your workflow.
     * @type {string}
     * @memberof OperatorVersion
     */
    name: string;
    /**
     * The tag of the operator
     * @type {string}
     * @memberof OperatorVersion
     */
    tag: string;
    /**
     * The version of the app binary backing the operator (CLI tool or container)
     * @type {string}
     * @memberof OperatorVersion
     */
    appVersion?: string;
    /**
     * A list of keywords to search the operator by
     * @type {Array<string>}
     * @memberof OperatorVersion
     */
    keywords?: Array<string>;
    /**
     * A list of maintainers for the operator
     * @type {Array<QueenbeeOperatorMetadataMaintainer>}
     * @memberof OperatorVersion
     */
    maintainers?: Array<QueenbeeOperatorMetadataMaintainer>;
    /**
     * The URL of this operator home page
     * @type {string}
     * @memberof OperatorVersion
     */
    home?: string;
    /**
     * A list of URLs to source code for this operator
     * @type {Array<string>}
     * @memberof OperatorVersion
     */
    sources?: Array<string>;
    /**
     * A URL to an SVG or PNG image to be used as an icon
     * @type {string}
     * @memberof OperatorVersion
     */
    icon?: string;
    /**
     * Whether this operator is deprecated
     * @type {boolean}
     * @memberof OperatorVersion
     */
    deprecated?: boolean;
    /**
     * A description of what this operator does
     * @type {string}
     * @memberof OperatorVersion
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof OperatorVersion
     */
    url: string;
    /**
     * 
     * @type {Date}
     * @memberof OperatorVersion
     */
    created: Date;
    /**
     * 
     * @type {string}
     * @memberof OperatorVersion
     */
    digest: string;
}
/**
 * 
 * @export
 * @interface OrgDto
 */
export interface OrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof OrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof OrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof OrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof OrgDto
     */
    description?: string;
    /**
     * The unique name of the org in small case without spaces
     * @type {string}
     * @memberof OrgDto
     */
    accountName: string;
    /**
     * The org ID
     * @type {string}
     * @memberof OrgDto
     */
    id: string;
    /**
     * The number of members that are part of this org
     * @type {number}
     * @memberof OrgDto
     */
    memberCount?: number;
    /**
     * The number of teams that are part of this org
     * @type {number}
     * @memberof OrgDto
     */
    teamCount?: number;
}
/**
 * 
 * @export
 * @interface OrgMemberDto
 */
export interface OrgMemberDto {
    /**
     * The org member account id
     * @type {string}
     * @memberof OrgMemberDto
     */
    userId: string;
    /**
     * The role the user has within the org
     * @type {string}
     * @memberof OrgMemberDto
     */
    role: OrgMemberDtoRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgMemberDtoRoleEnum {
    Owner = 'owner',
    Member = 'member'
}

/**
 * 
 * @export
 * @interface PackageAbridgedDto
 */
export interface PackageAbridgedDto {
    /**
     * The new package digest
     * @type {string}
     * @memberof PackageAbridgedDto
     */
    digest: string;
    /**
     * The new package tag
     * @type {string}
     * @memberof PackageAbridgedDto
     */
    tag: string;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof PackageAbridgedDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof PackageAbridgedDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof PackageAbridgedDto
     */
    icon?: string;
    /**
     * Creation Timestamp
     * @type {Date}
     * @memberof PackageAbridgedDto
     */
    createdAt?: Date;
}
/**
 * 
 * @export
 * @interface PackageDto
 */
export interface PackageDto {
    /**
     * The new package digest
     * @type {string}
     * @memberof PackageDto
     */
    digest: string;
    /**
     * The new package tag
     * @type {string}
     * @memberof PackageDto
     */
    tag: string;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof PackageDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof PackageDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof PackageDto
     */
    icon?: string;
    /**
     * Creation Timestamp
     * @type {Date}
     * @memberof PackageDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {object}
     * @memberof PackageDto
     */
    manifest: object;
    /**
     * The Repository Readme
     * @type {string}
     * @memberof PackageDto
     */
    readme?: string;
    /**
     * The Repository license
     * @type {string}
     * @memberof PackageDto
     */
    license?: string;
}
/**
 * A list response from a pagination request
 * @export
 * @interface PackageListDto
 */
export interface PackageListDto {
    /**
     * The current page the pagination request is on
     * @type {number}
     * @memberof PackageListDto
     */
    page: number;
    /**
     * The number of pages per pagination request
     * @type {number}
     * @memberof PackageListDto
     */
    perPage: number;
    /**
     * The next page, if this on is not the last
     * @type {number}
     * @memberof PackageListDto
     */
    nextPage?: number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof PackageListDto
     */
    pageCount: number;
    /**
     * The total number of resources matching the list request
     * @type {number}
     * @memberof PackageListDto
     */
    totalCount: number;
    /**
     * 
     * @type {Array<PackageAbridgedDto>}
     * @memberof PackageListDto
     */
    resources: Array<PackageAbridgedDto>;
}
/**
 * 
 * @export
 * @interface PatchOrgDto
 */
export interface PatchOrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof PatchOrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof PatchOrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof PatchOrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof PatchOrgDto
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface PatchProjectDto
 */
export interface PatchProjectDto {
    /**
     * The name of the project. Must be unique to a given owner
     * @type {string}
     * @memberof PatchProjectDto
     */
    name: string;
    /**
     * A description of the project
     * @type {string}
     * @memberof PatchProjectDto
     */
    description?: string;
    /**
     * Whether or not a project is publicly viewable
     * @type {boolean}
     * @memberof PatchProjectDto
     */
    _public?: boolean;
}
/**
 * 
 * @export
 * @interface PatchTeamDto
 */
export interface PatchTeamDto {
    /**
     * 
     * @type {string}
     * @memberof PatchTeamDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PatchTeamDto
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface PrivateUserDto
 */
export interface PrivateUserDto {
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    picture?: string;
    /**
     * 
     * @type {UserMetadata}
     * @memberof PrivateUserDto
     */
    metadata?: UserMetadata;
}
/**
 * 
 * @export
 * @interface ProjectAccessPolicyDto
 */
export interface ProjectAccessPolicyDto {
    /**
     * The subject the access policy refers to
     * @type {ProjectPolicySubjectDto}
     * @memberof ProjectAccessPolicyDto
     */
    subject: ProjectPolicySubjectDto;
    /**
     * The permission to associate with the policy subject. Can be one of `admin`, `contribute`, or `use`
     * @type {string}
     * @memberof ProjectAccessPolicyDto
     */
    permission: ProjectAccessPolicyDtoPermissionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectAccessPolicyDtoPermissionEnum {
    Admin = 'admin',
    Contribute = 'contribute',
    Read = 'read'
}

/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * The name of the project. Must be unique to a given owner
     * @type {string}
     * @memberof ProjectDto
     */
    name: string;
    /**
     * A description of the project
     * @type {string}
     * @memberof ProjectDto
     */
    description?: string;
    /**
     * Whether or not a project is publicly viewable
     * @type {boolean}
     * @memberof ProjectDto
     */
    _public?: boolean;
    /**
     * The project ID
     * @type {string}
     * @memberof ProjectDto
     */
    id: string;
    /**
     * 
     * @type {AccountPublic}
     * @memberof ProjectDto
     */
    owner: AccountPublic;
    /**
     * 
     * @type {ProjectPermissions}
     * @memberof ProjectDto
     */
    permissions: ProjectPermissions;
    /**
     * The project name in slug format
     * @type {string}
     * @memberof ProjectDto
     */
    slug: string;
}
/**
 * Project Folder Source  This is the path to a folder where files and folders can be sourced. In the context of a desktop run Workflow this folder will correspond to a local folder. In the context of a workflow run on Pollination this folder will correspond to a Project scoped folder.
 * @export
 * @interface ProjectFolderSource
 */
export interface ProjectFolderSource {
    /**
     * 
     * @type {string}
     * @memberof ProjectFolderSource
     */
    type: ProjectFolderSourceTypeEnum;
    /**
     * For a local filesystem this can be \"C:\\Users\\me\\simulations\\test\". This will correspond to the run specific folder .
     * @type {string}
     * @memberof ProjectFolderSource
     */
    path?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectFolderSourceTypeEnum {
    ProjectFolder = 'project-folder'
}

/**
 * 
 * @export
 * @interface ProjectPermissions
 */
export interface ProjectPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    admin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    contribute: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    read: boolean;
}
/**
 * 
 * @export
 * @interface ProjectPolicySubjectDto
 */
export interface ProjectPolicySubjectDto {
    /**
     * The type of policy subject. Can be `team`, `org` or `user`
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    type: string;
    /**
     * The ID of the policy subject
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    id: string;
    /**
     * The role within the policy subject that the access policy refers
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    role: string;
}
/**
 * 
 * @export
 * @interface PublicUserDto
 */
export interface PublicUserDto {
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    picture?: string;
}
/**
 * Maintainer information
 * @export
 * @interface QueenbeeOperatorMetadataMaintainer
 */
export interface QueenbeeOperatorMetadataMaintainer {
    /**
     * The name of the author/maintainer person or organization.
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMaintainer
     */
    name: string;
    /**
     * The email address of the author/maintainer person or organization.
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMaintainer
     */
    email?: string;
}
/**
 * Operator metadata information
 * @export
 * @interface QueenbeeOperatorMetadataMetaData
 */
export interface QueenbeeOperatorMetadataMetaData {
    /**
     * Operator name. This name should be unique among all the operators in your workflow.
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    name: string;
    /**
     * The tag of the operator
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    tag: string;
    /**
     * The version of the app binary backing the operator (CLI tool or container)
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    appVersion?: string;
    /**
     * A list of keywords to search the operator by
     * @type {Array<string>}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    keywords?: Array<string>;
    /**
     * A list of maintainers for the operator
     * @type {Array<QueenbeeOperatorMetadataMaintainer>}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    maintainers?: Array<QueenbeeOperatorMetadataMaintainer>;
    /**
     * The URL of this operator home page
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    home?: string;
    /**
     * A list of URLs to source code for this operator
     * @type {Array<string>}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    sources?: Array<string>;
    /**
     * A URL to an SVG or PNG image to be used as an icon
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    icon?: string;
    /**
     * Whether this operator is deprecated
     * @type {boolean}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    deprecated?: boolean;
    /**
     * A description of what this operator does
     * @type {string}
     * @memberof QueenbeeOperatorMetadataMetaData
     */
    description?: string;
}
/**
 * Maintainer information
 * @export
 * @interface QueenbeeRecipeMetadataMaintainer
 */
export interface QueenbeeRecipeMetadataMaintainer {
    /**
     * The name of the author/maintainer person or organization.
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMaintainer
     */
    name: string;
    /**
     * The email address of the author/maintainer person or organization.
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMaintainer
     */
    email?: string;
}
/**
 * Recipe metadata information.
 * @export
 * @interface QueenbeeRecipeMetadataMetaData
 */
export interface QueenbeeRecipeMetadataMetaData {
    /**
     * Recipe name. Make it descriptive and helpful ;)
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    name: string;
    /**
     * The tag of the recipe
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    tag: string;
    /**
     * A list of keywords to search the recipe by
     * @type {Array<string>}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    keywords?: Array<string>;
    /**
     * A list of maintainers for the recipe
     * @type {Array<QueenbeeRecipeMetadataMaintainer>}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    maintainers?: Array<QueenbeeRecipeMetadataMaintainer>;
    /**
     * The URL of this recipe\'s home page
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    home?: string;
    /**
     * A list of URLs to source code for this project
     * @type {Array<string>}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    sources?: Array<string>;
    /**
     * A URL to an SVG or PNG image to be used as an icon
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    icon?: string;
    /**
     * Whether this recipe is deprecated
     * @type {boolean}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    deprecated?: boolean;
    /**
     * A description of what this recipe does
     * @type {string}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    description?: string;
    /**
     * The license information.
     * @type {License}
     * @memberof QueenbeeRecipeMetadataMetaData
     */
    license?: License;
}
/**
 * A Queenbee Recipe
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * Recipe metadata information.
     * @type {QueenbeeRecipeMetadataMetaData}
     * @memberof Recipe
     */
    metadata?: QueenbeeRecipeMetadataMetaData;
    /**
     * A list of operators and other recipes this recipe depends on.
     * @type {Array<Dependency>}
     * @memberof Recipe
     */
    dependencies?: Array<Dependency>;
    /**
     * A list of tasks to create a DAG recipe.
     * @type {Array<DAG>}
     * @memberof Recipe
     */
    flow: Array<DAG>;
}
/**
 * 
 * @export
 * @interface RecipeSelection
 */
export interface RecipeSelection {
    /**
     * Name of the owner of the recipe
     * @type {string}
     * @memberof RecipeSelection
     */
    owner: string;
    /**
     * Name of the recipe
     * @type {string}
     * @memberof RecipeSelection
     */
    name: string;
    /**
     * The specific tag of the recipe to use
     * @type {string}
     * @memberof RecipeSelection
     */
    tag?: string;
}
/**
 * Resource Version  A Metadata object to distinguish a specific resource version within a repository index.
 * @export
 * @interface RecipeVersion
 */
export interface RecipeVersion {
    /**
     * Recipe name. Make it descriptive and helpful ;)
     * @type {string}
     * @memberof RecipeVersion
     */
    name: string;
    /**
     * The tag of the recipe
     * @type {string}
     * @memberof RecipeVersion
     */
    tag: string;
    /**
     * A list of keywords to search the recipe by
     * @type {Array<string>}
     * @memberof RecipeVersion
     */
    keywords?: Array<string>;
    /**
     * A list of maintainers for the recipe
     * @type {Array<QueenbeeRecipeMetadataMaintainer>}
     * @memberof RecipeVersion
     */
    maintainers?: Array<QueenbeeRecipeMetadataMaintainer>;
    /**
     * The URL of this recipe\'s home page
     * @type {string}
     * @memberof RecipeVersion
     */
    home?: string;
    /**
     * A list of URLs to source code for this project
     * @type {Array<string>}
     * @memberof RecipeVersion
     */
    sources?: Array<string>;
    /**
     * A URL to an SVG or PNG image to be used as an icon
     * @type {string}
     * @memberof RecipeVersion
     */
    icon?: string;
    /**
     * Whether this recipe is deprecated
     * @type {boolean}
     * @memberof RecipeVersion
     */
    deprecated?: boolean;
    /**
     * A description of what this recipe does
     * @type {string}
     * @memberof RecipeVersion
     */
    description?: string;
    /**
     * The license information.
     * @type {License}
     * @memberof RecipeVersion
     */
    license?: License;
    /**
     * 
     * @type {string}
     * @memberof RecipeVersion
     */
    url: string;
    /**
     * 
     * @type {Date}
     * @memberof RecipeVersion
     */
    created: Date;
    /**
     * 
     * @type {string}
     * @memberof RecipeVersion
     */
    digest: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    tokenName: string;
}
/**
 * 
 * @export
 * @interface RepositoryAbridgedDto
 */
export interface RepositoryAbridgedDto {
    /**
     * Whether or not a repository is publicly viewable
     * @type {boolean}
     * @memberof RepositoryAbridgedDto
     */
    _public?: boolean;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof RepositoryAbridgedDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof RepositoryAbridgedDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof RepositoryAbridgedDto
     */
    icon?: string;
    /**
     * The name of the repository
     * @type {string}
     * @memberof RepositoryAbridgedDto
     */
    name: string;
    /**
     * The latest package version to be indexed
     * @type {string}
     * @memberof RepositoryAbridgedDto
     */
    latestTag: string;
    /**
     * The owner of the repository
     * @type {AccountPublic}
     * @memberof RepositoryAbridgedDto
     */
    owner: AccountPublic;
    /**
     * The repository slug
     * @type {string}
     * @memberof RepositoryAbridgedDto
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface RepositoryDto
 */
export interface RepositoryDto {
    /**
     * Whether or not a repository is publicly viewable
     * @type {boolean}
     * @memberof RepositoryDto
     */
    _public?: boolean;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof RepositoryDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof RepositoryDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof RepositoryDto
     */
    icon?: string;
    /**
     * The name of the repository
     * @type {string}
     * @memberof RepositoryDto
     */
    name: string;
    /**
     * The latest package version to be indexed
     * @type {string}
     * @memberof RepositoryDto
     */
    latestTag: string;
    /**
     * The owner of the repository
     * @type {AccountPublic}
     * @memberof RepositoryDto
     */
    owner: AccountPublic;
    /**
     * The repository slug
     * @type {string}
     * @memberof RepositoryDto
     */
    slug?: string;
    /**
     * The permissions the user making the API call has on the resource
     * @type {RepositoryPermissions}
     * @memberof RepositoryDto
     */
    permissions: RepositoryPermissions;
}
/**
 * A searchable index for a Queenbee Operator and Recipe repository
 * @export
 * @interface RepositoryIndex
 */
export interface RepositoryIndex {
    /**
     * The timestamp at which the index was generated
     * @type {Date}
     * @memberof RepositoryIndex
     */
    generated?: Date;
    /**
     * A dict of operators accessible by name. Each name key points to a list of operator versions
     * @type {{ [key: string]: Array<OperatorVersion>; }}
     * @memberof RepositoryIndex
     */
    operator?: { [key: string]: Array<OperatorVersion>; };
    /**
     * A dict of recipes accessible by name. Each name key points to a list of recipesversions
     * @type {{ [key: string]: Array<RecipeVersion>; }}
     * @memberof RepositoryIndex
     */
    recipe?: { [key: string]: Array<RecipeVersion>; };
}
/**
 * A list response from a pagination request
 * @export
 * @interface RepositoryListDto
 */
export interface RepositoryListDto {
    /**
     * The current page the pagination request is on
     * @type {number}
     * @memberof RepositoryListDto
     */
    page: number;
    /**
     * The number of pages per pagination request
     * @type {number}
     * @memberof RepositoryListDto
     */
    perPage: number;
    /**
     * The next page, if this on is not the last
     * @type {number}
     * @memberof RepositoryListDto
     */
    nextPage?: number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof RepositoryListDto
     */
    pageCount: number;
    /**
     * The total number of resources matching the list request
     * @type {number}
     * @memberof RepositoryListDto
     */
    totalCount: number;
    /**
     * 
     * @type {Array<RepositoryAbridgedDto>}
     * @memberof RepositoryListDto
     */
    resources: Array<RepositoryAbridgedDto>;
}
/**
 * 
 * @export
 * @interface RepositoryPermissions
 */
export interface RepositoryPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryPermissions
     */
    admin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryPermissions
     */
    contribute: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryPermissions
     */
    read: boolean;
}
/**
 * S3Source  An S3 bucket artifact Source.
 * @export
 * @interface S3Source
 */
export interface S3Source {
    /**
     * 
     * @type {string}
     * @memberof S3Source
     */
    type: S3SourceTypeEnum;
    /**
     * The path inside the bucket to source artifacts from.
     * @type {string}
     * @memberof S3Source
     */
    key: string;
    /**
     * The HTTP endpoint to reach the S3 bucket.
     * @type {string}
     * @memberof S3Source
     */
    endpoint: string;
    /**
     * The name of the S3 bucket on the host server.
     * @type {string}
     * @memberof S3Source
     */
    bucket: string;
    /**
     * Path to the file holding the AccessKey and SecretAccessKey to authenticate to the bucket. Assumes public bucket access if none are specified.
     * @type {string}
     * @memberof S3Source
     */
    credentialsPath?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum S3SourceTypeEnum {
    S3 = 's3'
}

/**
 * 
 * @export
 * @interface S3UploadRequest
 */
export interface S3UploadRequest {
    /**
     * 
     * @type {string}
     * @memberof S3UploadRequest
     */
    url: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof S3UploadRequest
     */
    fields: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    password: string;
    /**
     * 
     * @type {UserMetadata}
     * @memberof SignUpDto
     */
    metadata: UserMetadata;
}
/**
 * A list response from a pagination request
 * @export
 * @interface SimulationList
 */
export interface SimulationList {
    /**
     * The current page the pagination request is on
     * @type {number}
     * @memberof SimulationList
     */
    page: number;
    /**
     * The number of pages per pagination request
     * @type {number}
     * @memberof SimulationList
     */
    perPage: number;
    /**
     * The next page, if this on is not the last
     * @type {number}
     * @memberof SimulationList
     */
    nextPage?: number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof SimulationList
     */
    pageCount: number;
    /**
     * The total number of resources matching the list request
     * @type {number}
     * @memberof SimulationList
     */
    totalCount: number;
    /**
     * 
     * @type {Array<WorkflowStatus>}
     * @memberof SimulationList
     */
    resources: Array<WorkflowStatus>;
}
/**
 * Workflow Status
 * @export
 * @interface SimulationStatus
 */
export interface SimulationStatus {
    /**
     * The status of this task. Can be \"Running\", \"Succeeded\", \"Failed\" or \"Error\"
     * @type {string}
     * @memberof SimulationStatus
     */
    status: string;
    /**
     * Any message produced by the task. Usually error/debugging hints.
     * @type {string}
     * @memberof SimulationStatus
     */
    message?: string;
    /**
     * The time at which the task was started
     * @type {Date}
     * @memberof SimulationStatus
     */
    startedAt: Date;
    /**
     * The time at which the task was completed
     * @type {Date}
     * @memberof SimulationStatus
     */
    finishedAt?: Date;
    /**
     * The ID of the individual workflow run.
     * @type {string}
     * @memberof SimulationStatus
     */
    id: string;
    /**
     * The ID of the first task in the workflow
     * @type {string}
     * @memberof SimulationStatus
     */
    entrypoint?: string;
    /**
     * 
     * @type {{ [key: string]: TaskStatus; }}
     * @memberof SimulationStatus
     */
    tasks?: { [key: string]: TaskStatus; };
    /**
     * ID of the account the simulation is running for.
     * @type {string}
     * @memberof SimulationStatus
     */
    ownerId: string;
    /**
     * ID of the project the simulation belongs to
     * @type {string}
     * @memberof SimulationStatus
     */
    projectId: string;
    /**
     * ID of the recipe repository used to create the workflow
     * @type {string}
     * @memberof SimulationStatus
     */
    recipeId: string;
    /**
     * ID of the recipe owner
     * @type {string}
     * @memberof SimulationStatus
     */
    recipeOwnerId: string;
    /**
     * ID of the specific recipe package used to create the workflow
     * @type {string}
     * @memberof SimulationStatus
     */
    recipePackageId: string;
    /**
     * The max number of parallel tasks running for this simulation
     * @type {number}
     * @memberof SimulationStatus
     */
    parallelism?: number;
}
/**
 * 
 * @export
 * @interface SubmitSimulationDto
 */
export interface SubmitSimulationDto {
    /**
     * The recipe to use
     * @type {RecipeSelection}
     * @memberof SubmitSimulationDto
     */
    recipe: RecipeSelection;
    /**
     * Simulation inputs
     * @type {Arguments}
     * @memberof SubmitSimulationDto
     */
    inputs?: Arguments;
}
/**
 * A Task Artifact Reference
 * @export
 * @interface TaskArtifactReference
 */
export interface TaskArtifactReference {
    /**
     * 
     * @type {string}
     * @memberof TaskArtifactReference
     */
    type?: TaskArtifactReferenceTypeEnum;
    /**
     * The name of the task to pull output data from
     * @type {string}
     * @memberof TaskArtifactReference
     */
    name: string;
    /**
     * The name of the task output variable
     * @type {string}
     * @memberof TaskArtifactReference
     */
    variable: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TaskArtifactReferenceTypeEnum {
    Tasks = 'tasks'
}

/**
 * A Task Parameter Reference
 * @export
 * @interface TaskParameterReference
 */
export interface TaskParameterReference {
    /**
     * 
     * @type {string}
     * @memberof TaskParameterReference
     */
    type?: TaskParameterReferenceTypeEnum;
    /**
     * The name of the task to pull output data from
     * @type {string}
     * @memberof TaskParameterReference
     */
    name: string;
    /**
     * The name of the task output variable
     * @type {string}
     * @memberof TaskParameterReference
     */
    variable: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TaskParameterReferenceTypeEnum {
    Tasks = 'tasks'
}

/**
 * The Status of a Workflow Task
 * @export
 * @interface TaskStatus
 */
export interface TaskStatus {
    /**
     * The status of this task. Can be \"Running\", \"Succeeded\", \"Failed\" or \"Error\"
     * @type {string}
     * @memberof TaskStatus
     */
    status: string;
    /**
     * Any message produced by the task. Usually error/debugging hints.
     * @type {string}
     * @memberof TaskStatus
     */
    message?: string;
    /**
     * The time at which the task was started
     * @type {Date}
     * @memberof TaskStatus
     */
    startedAt: Date;
    /**
     * The time at which the task was completed
     * @type {Date}
     * @memberof TaskStatus
     */
    finishedAt?: Date;
    /**
     * The task unique ID
     * @type {string}
     * @memberof TaskStatus
     */
    id: string;
    /**
     * A human readable name for the task. Usually defined by the DAG task name but can be extended if the task is part of a loop for example. This name is unique within the boundary of the DAG/Workflow that generated it.
     * @type {string}
     * @memberof TaskStatus
     */
    name: string;
    /**
     * The type of task this status is for. Can be \"function\", \"dag\" or \"loop\"
     * @type {string}
     * @memberof TaskStatus
     */
    type: TaskStatusTypeEnum;
    /**
     * The name of the template that spawned this task
     * @type {string}
     * @memberof TaskStatus
     */
    templateRef: string;
    /**
     * The command used to run this task. Only applies to Function tasks.
     * @type {string}
     * @memberof TaskStatus
     */
    command?: string;
    /**
     * The inputs used by this task
     * @type {Arguments}
     * @memberof TaskStatus
     */
    inputs: Arguments;
    /**
     * The outputs produced by this task
     * @type {Arguments}
     * @memberof TaskStatus
     */
    outputs: Arguments;
    /**
     * This indicates the task ID of the associated template root             task in which this task belongs to. A DAG task will have the id of the             parent DAG for example.
     * @type {string}
     * @memberof TaskStatus
     */
    boundaryId?: string;
    /**
     * A list of child task IDs
     * @type {Array<string>}
     * @memberof TaskStatus
     */
    children: Array<string>;
    /**
     * A list of the last tasks to ran in the context of this task. In the case of a DAG or a workflow this will be the last task that has been executed. It will remain empty for functions.
     * @type {Array<string>}
     * @memberof TaskStatus
     */
    outboundTasks: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum TaskStatusTypeEnum {
    Function = 'function',
    Dag = 'dag',
    Loop = 'loop'
}

/**
 * 
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    slug: string;
    /**
     * 
     * @type {TeamOrg}
     * @memberof TeamDto
     */
    org: TeamOrg;
    /**
     * The number of members that are part of this org
     * @type {number}
     * @memberof TeamDto
     */
    memberCount?: number;
}
/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * The team member
     * @type {string}
     * @memberof TeamMemberDto
     */
    userId: string;
    /**
     * The role the user has within the team
     * @type {string}
     * @memberof TeamMemberDto
     */
    role: TeamMemberDtoRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TeamMemberDtoRoleEnum {
    Owner = 'owner',
    Member = 'member'
}

/**
 * 
 * @export
 * @interface TeamOrg
 */
export interface TeamOrg {
    /**
     * The Account name of the org the team belongs to
     * @type {string}
     * @memberof TeamOrg
     */
    accountName: string;
}
/**
 * Accepted request response for existing resource
 * @export
 * @interface UpdateAccepted
 */
export interface UpdateAccepted {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccepted
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface UpdateRepositoryDto
 */
export interface UpdateRepositoryDto {
    /**
     * Whether or not a repository is publicly viewable
     * @type {boolean}
     * @memberof UpdateRepositoryDto
     */
    _public?: boolean;
    /**
     * keywords
     * @type {Array<string>}
     * @memberof UpdateRepositoryDto
     */
    keywords?: Array<string>;
    /**
     * description
     * @type {string}
     * @memberof UpdateRepositoryDto
     */
    description?: string;
    /**
     * icon
     * @type {string}
     * @memberof UpdateRepositoryDto
     */
    icon?: string;
}
/**
 * 
 * @export
 * @interface UserMetadata
 */
export interface UserMetadata {
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * Workflow Status
 * @export
 * @interface WorkflowStatus
 */
export interface WorkflowStatus {
    /**
     * The status of this task. Can be \"Running\", \"Succeeded\", \"Failed\" or \"Error\"
     * @type {string}
     * @memberof WorkflowStatus
     */
    status: string;
    /**
     * Any message produced by the task. Usually error/debugging hints.
     * @type {string}
     * @memberof WorkflowStatus
     */
    message?: string;
    /**
     * The time at which the task was started
     * @type {Date}
     * @memberof WorkflowStatus
     */
    startedAt: Date;
    /**
     * The time at which the task was completed
     * @type {Date}
     * @memberof WorkflowStatus
     */
    finishedAt?: Date;
    /**
     * The ID of the individual workflow run.
     * @type {string}
     * @memberof WorkflowStatus
     */
    id: string;
    /**
     * The ID of the first task in the workflow
     * @type {string}
     * @memberof WorkflowStatus
     */
    entrypoint?: string;
    /**
     * 
     * @type {{ [key: string]: TaskStatus; }}
     * @memberof WorkflowStatus
     */
    tasks?: { [key: string]: TaskStatus; };
}

/**
 * AccountsApi - axios parameter creator
 * @export
 * @hidden
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAccount.');
            }
            const localVarPath = `/accounts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 * @hidden
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPublic> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccount(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 * @hidden
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options?: any) {
            return AccountsApiFp(configuration).getAccount(name, options)(axios, basePath);
        },
    };
};

/**
 * AccountsApi - interface
 * @export
 * @interface AccountsApi
 */
export interface AccountsApiInterface {
    /**
     * Retrieve a workflow by name
     * @summary Get an account by name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getAccount(name: string, options?: any): AxiosPromise<AccountPublic>;

}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI implements AccountsApiInterface {
    /**
     * Retrieve a workflow by name
     * @summary Get an account by name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(name: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccount(name, options)(this.axios, this.basePath);
    }

}


/**
 * ArtifactsApi - axios parameter creator
 * @export
 * @hidden
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'keyRequest' is not null or undefined
            if (keyRequest === null || keyRequest === undefined) {
                throw new RequiredError('keyRequest','Required parameter keyRequest was null or undefined when calling createArtifact.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof keyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(keyRequest !== undefined ? keyRequest : {}) : (keyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteArtifact.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifacts.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listArtifacts.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 * @hidden
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3UploadRequest> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).createArtifact(owner, name, keyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).deleteArtifact(owner, name, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileMeta>> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).listArtifacts(owner, name, page, perPage, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 * @hidden
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any) {
            return ArtifactsApiFp(configuration).createArtifact(owner, name, keyRequest, options)(axios, basePath);
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any) {
            return ArtifactsApiFp(configuration).deleteArtifact(owner, name, path, options)(axios, basePath);
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any) {
            return ArtifactsApiFp(configuration).listArtifacts(owner, name, page, perPage, path, options)(axios, basePath);
        },
    };
};

/**
 * ArtifactsApi - interface
 * @export
 * @interface ArtifactsApi
 */
export interface ArtifactsApiInterface {
    /**
     * Create a new artifact.
     * @summary Get an Artifact upload link.
     * @param {string} owner 
     * @param {string} name 
     * @param {KeyRequest} keyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any): AxiosPromise<S3UploadRequest>;

    /**
     * Delete one or multiple artifacts based on key prefix
     * @summary Delete one or many artifacts by key/prefix
     * @param {string} owner 
     * @param {string} name 
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Retrieve a list of artifacts.
     * @summary List artifacts in a project folder
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any): AxiosPromise<Array<FileMeta>>;

}

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI implements ArtifactsApiInterface {
    /**
     * Create a new artifact.
     * @summary Get an Artifact upload link.
     * @param {string} owner 
     * @param {string} name 
     * @param {KeyRequest} keyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).createArtifact(owner, name, keyRequest, options)(this.axios, this.basePath);
    }

    /**
     * Delete one or multiple artifacts based on key prefix
     * @summary Delete one or many artifacts by key/prefix
     * @param {string} owner 
     * @param {string} name 
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any) {
        return ArtifactsApiFp(this.configuration).deleteArtifact(owner, name, path, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of artifacts.
     * @summary List artifacts in a project folder
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any) {
        return ArtifactsApiFp(this.configuration).listArtifacts(owner, name, page, perPage, path, options)(this.axios, this.basePath);
    }

}


/**
 * OperatorsApi - axios parameter creator
 * @export
 * @hidden
 */
export const OperatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new operator.
         * @summary Create an Operator
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperator(owner: string, newRepositoryDto: NewRepositoryDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createOperator.');
            }
            // verify required parameter 'newRepositoryDto' is not null or undefined
            if (newRepositoryDto === null || newRepositoryDto === undefined) {
                throw new RequiredError('newRepositoryDto','Required parameter newRepositoryDto was null or undefined when calling createOperator.');
            }
            const localVarPath = `/operators/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof newRepositoryDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newRepositoryDto !== undefined ? newRepositoryDto : {}) : (newRepositoryDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new operator package version
         * @summary Create a new Operator package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewOperatorPackage} newOperatorPackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperatorPackage(owner: string, name: string, newOperatorPackage: NewOperatorPackage, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createOperatorPackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createOperatorPackage.');
            }
            // verify required parameter 'newOperatorPackage' is not null or undefined
            if (newOperatorPackage === null || newOperatorPackage === undefined) {
                throw new RequiredError('newOperatorPackage','Required parameter newOperatorPackage was null or undefined when calling createOperatorPackage.');
            }
            const localVarPath = `/operators/{owner}/{name}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof newOperatorPackage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newOperatorPackage !== undefined ? newOperatorPackage : {}) : (newOperatorPackage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an operator (must have `admin` permission)
         * @summary Delete an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperator(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteOperator.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteOperator.');
            }
            const localVarPath = `/operators/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperator(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOperator.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOperator.');
            }
            const localVarPath = `/operators/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an operator tag by name and tag
         * @summary Get an operator tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTag(owner: string, name: string, tag: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOperatorTag.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOperatorTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getOperatorTag.');
            }
            const localVarPath = `/operators/{owner}/{name}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTags(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOperatorTags.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOperatorTags.');
            }
            const localVarPath = `/operators/{owner}/{name}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List operators
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperators(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/operators`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (owner) {
                localVarQueryParameter['owner'] = owner;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (keyword) {
                localVarQueryParameter['keyword'] = keyword;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an operator (must have `contribute` permission)
         * @summary Update an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperator(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateOperator.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateOperator.');
            }
            // verify required parameter 'updateRepositoryDto' is not null or undefined
            if (updateRepositoryDto === null || updateRepositoryDto === undefined) {
                throw new RequiredError('updateRepositoryDto','Required parameter updateRepositoryDto was null or undefined when calling updateOperator.');
            }
            const localVarPath = `/operators/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof updateRepositoryDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateRepositoryDto !== undefined ? updateRepositoryDto : {}) : (updateRepositoryDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperatorsApi - functional programming interface
 * @export
 * @hidden
 */
export const OperatorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new operator.
         * @summary Create an Operator
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperator(owner: string, newRepositoryDto: NewRepositoryDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).createOperator(owner, newRepositoryDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new operator package version
         * @summary Create a new Operator package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewOperatorPackage} newOperatorPackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperatorPackage(owner: string, name: string, newOperatorPackage: NewOperatorPackage, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).createOperatorPackage(owner, name, newOperatorPackage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an operator (must have `admin` permission)
         * @summary Delete an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperator(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).deleteOperator(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperator(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).getOperator(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve an operator tag by name and tag
         * @summary Get an operator tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTag(owner: string, name: string, tag: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).getOperatorTag(owner, name, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTags(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).getOperatorTags(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List operators
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperators(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryListDto> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).listOperators(page, perPage, name, owner, _public, keyword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an operator (must have `contribute` permission)
         * @summary Update an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperator(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = OperatorsApiAxiosParamCreator(configuration).updateOperator(owner, name, updateRepositoryDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperatorsApi - factory interface
 * @export
 * @hidden
 */
export const OperatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new operator.
         * @summary Create an Operator
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperator(owner: string, newRepositoryDto: NewRepositoryDto, options?: any) {
            return OperatorsApiFp(configuration).createOperator(owner, newRepositoryDto, options)(axios, basePath);
        },
        /**
         * Create a new operator package version
         * @summary Create a new Operator package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewOperatorPackage} newOperatorPackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperatorPackage(owner: string, name: string, newOperatorPackage: NewOperatorPackage, options?: any) {
            return OperatorsApiFp(configuration).createOperatorPackage(owner, name, newOperatorPackage, options)(axios, basePath);
        },
        /**
         * Delete an operator (must have `admin` permission)
         * @summary Delete an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperator(owner: string, name: string, options?: any) {
            return OperatorsApiFp(configuration).deleteOperator(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperator(owner: string, name: string, options?: any) {
            return OperatorsApiFp(configuration).getOperator(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve an operator tag by name and tag
         * @summary Get an operator tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTag(owner: string, name: string, tag: string, options?: any) {
            return OperatorsApiFp(configuration).getOperatorTag(owner, name, tag, options)(axios, basePath);
        },
        /**
         * Retrieve an operator by name
         * @summary Get an operator tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorTags(owner: string, name: string, options?: any) {
            return OperatorsApiFp(configuration).getOperatorTags(owner, name, options)(axios, basePath);
        },
        /**
         * 
         * @summary List operators
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperators(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any) {
            return OperatorsApiFp(configuration).listOperators(page, perPage, name, owner, _public, keyword, options)(axios, basePath);
        },
        /**
         * Update an operator (must have `contribute` permission)
         * @summary Update an Operator
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperator(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any) {
            return OperatorsApiFp(configuration).updateOperator(owner, name, updateRepositoryDto, options)(axios, basePath);
        },
    };
};

/**
 * OperatorsApi - interface
 * @export
 * @interface OperatorsApi
 */
export interface OperatorsApiInterface {
    /**
     * Create a new operator.
     * @summary Create an Operator
     * @param {string} owner 
     * @param {NewRepositoryDto} newRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    createOperator(owner: string, newRepositoryDto: NewRepositoryDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Create a new operator package version
     * @summary Create a new Operator package
     * @param {string} owner 
     * @param {string} name 
     * @param {NewOperatorPackage} newOperatorPackage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    createOperatorPackage(owner: string, name: string, newOperatorPackage: NewOperatorPackage, options?: any): AxiosPromise<object>;

    /**
     * Delete an operator (must have `admin` permission)
     * @summary Delete an Operator
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    deleteOperator(owner: string, name: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve an operator by name
     * @summary Get an operator
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    getOperator(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve an operator tag by name and tag
     * @summary Get an operator tag
     * @param {string} owner 
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    getOperatorTag(owner: string, name: string, tag: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve an operator by name
     * @summary Get an operator tags
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    getOperatorTags(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary List operators
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [keyword] A keyword to index the repository by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    listOperators(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any): AxiosPromise<RepositoryListDto>;

    /**
     * Update an operator (must have `contribute` permission)
     * @summary Update an Operator
     * @param {string} owner 
     * @param {string} name 
     * @param {UpdateRepositoryDto} updateRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApiInterface
     */
    updateOperator(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * OperatorsApi - object-oriented interface
 * @export
 * @class OperatorsApi
 * @extends {BaseAPI}
 */
export class OperatorsApi extends BaseAPI implements OperatorsApiInterface {
    /**
     * Create a new operator.
     * @summary Create an Operator
     * @param {string} owner 
     * @param {NewRepositoryDto} newRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public createOperator(owner: string, newRepositoryDto: NewRepositoryDto, options?: any) {
        return OperatorsApiFp(this.configuration).createOperator(owner, newRepositoryDto, options)(this.axios, this.basePath);
    }

    /**
     * Create a new operator package version
     * @summary Create a new Operator package
     * @param {string} owner 
     * @param {string} name 
     * @param {NewOperatorPackage} newOperatorPackage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public createOperatorPackage(owner: string, name: string, newOperatorPackage: NewOperatorPackage, options?: any) {
        return OperatorsApiFp(this.configuration).createOperatorPackage(owner, name, newOperatorPackage, options)(this.axios, this.basePath);
    }

    /**
     * Delete an operator (must have `admin` permission)
     * @summary Delete an Operator
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public deleteOperator(owner: string, name: string, options?: any) {
        return OperatorsApiFp(this.configuration).deleteOperator(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve an operator by name
     * @summary Get an operator
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public getOperator(owner: string, name: string, options?: any) {
        return OperatorsApiFp(this.configuration).getOperator(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve an operator tag by name and tag
     * @summary Get an operator tag
     * @param {string} owner 
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public getOperatorTag(owner: string, name: string, tag: string, options?: any) {
        return OperatorsApiFp(this.configuration).getOperatorTag(owner, name, tag, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve an operator by name
     * @summary Get an operator tags
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public getOperatorTags(owner: string, name: string, options?: any) {
        return OperatorsApiFp(this.configuration).getOperatorTags(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List operators
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [keyword] A keyword to index the repository by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public listOperators(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any) {
        return OperatorsApiFp(this.configuration).listOperators(page, perPage, name, owner, _public, keyword, options)(this.axios, this.basePath);
    }

    /**
     * Update an operator (must have `contribute` permission)
     * @summary Update an Operator
     * @param {string} owner 
     * @param {string} name 
     * @param {UpdateRepositoryDto} updateRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public updateOperator(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any) {
        return OperatorsApiFp(this.configuration).updateOperator(owner, name, updateRepositoryDto, options)(this.axios, this.basePath);
    }

}


/**
 * OrgsApi - axios parameter creator
 * @export
 * @hidden
 */
export const OrgsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options: any = {}): RequestArgs {
            // verify required parameter 'createOrgDto' is not null or undefined
            if (createOrgDto === null || createOrgDto === undefined) {
                throw new RequiredError('createOrgDto','Required parameter createOrgDto was null or undefined when calling createOrg.');
            }
            const localVarPath = `/orgs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createOrgDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createOrgDto !== undefined ? createOrgDto : {}) : (createOrgDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteOrgMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteOrgMember.');
            }
            const localVarPath = `/orgs/{name}/members/{username}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOrgMembers.');
            }
            const localVarPath = `/orgs/{name}/members`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/orgs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (member) {
                localVarQueryParameter['member'] = member;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateOrg.');
            }
            // verify required parameter 'patchOrgDto' is not null or undefined
            if (patchOrgDto === null || patchOrgDto === undefined) {
                throw new RequiredError('patchOrgDto','Required parameter patchOrgDto was null or undefined when calling updateOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchOrgDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOrgDto !== undefined ? patchOrgDto : {}) : (patchOrgDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertOrgMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling upsertOrgMember.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling upsertOrgMember.');
            }
            const localVarPath = `/orgs/{name}/members/{username}/{role}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgsApi - functional programming interface
 * @export
 * @hidden
 */
export const OrgsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).createOrg(createOrgDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).deleteOrg(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).deleteOrgMember(name, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).getOrg(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgMemberDto>> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).getOrgMembers(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgDto>> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).listOrgs(page, perPage, name, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).updateOrg(name, patchOrgDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).upsertOrgMember(name, username, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrgsApi - factory interface
 * @export
 * @hidden
 */
export const OrgsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options?: any) {
            return OrgsApiFp(configuration).createOrg(createOrgDto, options)(axios, basePath);
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options?: any) {
            return OrgsApiFp(configuration).deleteOrg(name, options)(axios, basePath);
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options?: any) {
            return OrgsApiFp(configuration).deleteOrgMember(name, username, options)(axios, basePath);
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options?: any) {
            return OrgsApiFp(configuration).getOrg(name, options)(axios, basePath);
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options?: any) {
            return OrgsApiFp(configuration).getOrgMembers(name, options)(axios, basePath);
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
            return OrgsApiFp(configuration).listOrgs(page, perPage, name, member, options)(axios, basePath);
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any) {
            return OrgsApiFp(configuration).updateOrg(name, patchOrgDto, options)(axios, basePath);
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any) {
            return OrgsApiFp(configuration).upsertOrgMember(name, username, role, options)(axios, basePath);
        },
    };
};

/**
 * OrgsApi - interface
 * @export
 * @interface OrgsApi
 */
export interface OrgsApiInterface {
    /**
     * Create a new org.
     * @summary Create an Org
     * @param {CreateOrgDto} createOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    createOrg(createOrgDto: CreateOrgDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Delete a org (must have `admin` permission)
     * @summary Delete an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    deleteOrg(name: string, options?: any): AxiosPromise<{}>;

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove an Org member
     * @param {string} name 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    deleteOrgMember(name: string, username: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a org by name
     * @summary Get an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    getOrg(name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a org\'s members
     * @summary List an Org\'s members
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    getOrgMembers(name: string, options?: any): AxiosPromise<Array<OrgMemberDto>>;

    /**
     * search for orgs using query parameters
     * @summary List Orgs
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): AxiosPromise<Array<OrgDto>>;

    /**
     * Update a org (must have org `owner` role)
     * @summary Update an Org
     * @param {string} name 
     * @param {PatchOrgDto} patchOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a member role to the org (must have org `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} name 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * OrgsApi - object-oriented interface
 * @export
 * @class OrgsApi
 * @extends {BaseAPI}
 */
export class OrgsApi extends BaseAPI implements OrgsApiInterface {
    /**
     * Create a new org.
     * @summary Create an Org
     * @param {CreateOrgDto} createOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public createOrg(createOrgDto: CreateOrgDto, options?: any) {
        return OrgsApiFp(this.configuration).createOrg(createOrgDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete a org (must have `admin` permission)
     * @summary Delete an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public deleteOrg(name: string, options?: any) {
        return OrgsApiFp(this.configuration).deleteOrg(name, options)(this.axios, this.basePath);
    }

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove an Org member
     * @param {string} name 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public deleteOrgMember(name: string, username: string, options?: any) {
        return OrgsApiFp(this.configuration).deleteOrgMember(name, username, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a org by name
     * @summary Get an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrg(name: string, options?: any) {
        return OrgsApiFp(this.configuration).getOrg(name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a org\'s members
     * @summary List an Org\'s members
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgMembers(name: string, options?: any) {
        return OrgsApiFp(this.configuration).getOrgMembers(name, options)(this.axios, this.basePath);
    }

    /**
     * search for orgs using query parameters
     * @summary List Orgs
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
        return OrgsApiFp(this.configuration).listOrgs(page, perPage, name, member, options)(this.axios, this.basePath);
    }

    /**
     * Update a org (must have org `owner` role)
     * @summary Update an Org
     * @param {string} name 
     * @param {PatchOrgDto} patchOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any) {
        return OrgsApiFp(this.configuration).updateOrg(name, patchOrgDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a member role to the org (must have org `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} name 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any) {
        return OrgsApiFp(this.configuration).upsertOrgMember(name, username, role, options)(this.axios, this.basePath);
    }

}


/**
 * ProjectsApi - axios parameter creator
 * @export
 * @hidden
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'patchProjectDto' is not null or undefined
            if (patchProjectDto === null || patchProjectDto === undefined) {
                throw new RequiredError('patchProjectDto','Required parameter patchProjectDto was null or undefined when calling createProject.');
            }
            const localVarPath = `/projects/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchProjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchProjectDto !== undefined ? patchProjectDto : {}) : (patchProjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectOrgPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteProjectOrgPermission.');
            }
            // verify required parameter 'projectPolicySubjectDto' is not null or undefined
            if (projectPolicySubjectDto === null || projectPolicySubjectDto === undefined) {
                throw new RequiredError('projectPolicySubjectDto','Required parameter projectPolicySubjectDto was null or undefined when calling deleteProjectOrgPermission.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof projectPolicySubjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectPolicySubjectDto !== undefined ? projectPolicySubjectDto : {}) : (projectPolicySubjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectAccessPermissions.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getProjectAccessPermissions.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/projects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (owner) {
                localVarQueryParameter['owner'] = owner;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (operator) {
                localVarQueryParameter['operator'] = operator;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling update.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling update.');
            }
            // verify required parameter 'patchProjectDto' is not null or undefined
            if (patchProjectDto === null || patchProjectDto === undefined) {
                throw new RequiredError('patchProjectDto','Required parameter patchProjectDto was null or undefined when calling update.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchProjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchProjectDto !== undefined ? patchProjectDto : {}) : (patchProjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling upsertProjectPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertProjectPermission.');
            }
            // verify required parameter 'projectAccessPolicyDto' is not null or undefined
            if (projectAccessPolicyDto === null || projectAccessPolicyDto === undefined) {
                throw new RequiredError('projectAccessPolicyDto','Required parameter projectAccessPolicyDto was null or undefined when calling upsertProjectPermission.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof projectAccessPolicyDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectAccessPolicyDto !== undefined ? projectAccessPolicyDto : {}) : (projectAccessPolicyDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 * @hidden
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).createProject(owner, patchProjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).deleteProject(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProject(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectAccessPolicyDto>> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProjectAccessPermissions(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).listProjects(page, perPage, id, name, owner, _public, operator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).update(owner, name, patchProjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 * @hidden
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any) {
            return ProjectsApiFp(configuration).createProject(owner, patchProjectDto, options)(axios, basePath);
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProject(owner, name, options)(axios, basePath);
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any) {
            return ProjectsApiFp(configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options)(axios, basePath);
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getProject(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectAccessPermissions(owner, name, options)(axios, basePath);
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
            return ProjectsApiFp(configuration).listProjects(page, perPage, id, name, owner, _public, operator, options)(axios, basePath);
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any) {
            return ProjectsApiFp(configuration).update(owner, name, patchProjectDto, options)(axios, basePath);
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any) {
            return ProjectsApiFp(configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options)(axios, basePath);
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * Create a new project.
     * @summary Create a Project
     * @param {string} owner 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Delete a project (must have `admin` permission)
     * @summary Delete a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    deleteProject(owner: string, name: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a project\'s access policy (must have `admin` permission)
     * @summary Remove a Project permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a project by name
     * @summary Get a project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    getProject(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a project\'s access permissions (must have `contribute` permission)
     * @summary Get a project\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    getProjectAccessPermissions(owner: string, name: string, options?: any): AxiosPromise<Array<ProjectAccessPolicyDto>>;

    /**
     * search for projects using query parameters
     * @summary List Projects
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): AxiosPromise<Array<ProjectDto>>;

    /**
     * Update a project (must have `contribute` permission)
     * @summary Update a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a project\'s access policy (must have `admin` permission)
     * @summary Upsert a new permission to a project
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Create a new project.
     * @summary Create a Project
     * @param {string} owner 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).createProject(owner, patchProjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete a project (must have `admin` permission)
     * @summary Delete a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Delete a project\'s access policy (must have `admin` permission)
     * @summary Remove a Project permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a project by name
     * @summary Get a project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a project\'s access permissions (must have `contribute` permission)
     * @summary Get a project\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectAccessPermissions(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectAccessPermissions(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * search for projects using query parameters
     * @summary List Projects
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
        return ProjectsApiFp(this.configuration).listProjects(page, perPage, id, name, owner, _public, operator, options)(this.axios, this.basePath);
    }

    /**
     * Update a project (must have `contribute` permission)
     * @summary Update a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).update(owner, name, patchProjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a project\'s access policy (must have `admin` permission)
     * @summary Upsert a new permission to a project
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any) {
        return ProjectsApiFp(this.configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options)(this.axios, this.basePath);
    }

}


/**
 * RecipesApi - axios parameter creator
 * @export
 * @hidden
 */
export const RecipesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new recipe.
         * @summary Create a Recipe
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(owner: string, newRepositoryDto: NewRepositoryDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRecipe.');
            }
            // verify required parameter 'newRepositoryDto' is not null or undefined
            if (newRepositoryDto === null || newRepositoryDto === undefined) {
                throw new RequiredError('newRepositoryDto','Required parameter newRepositoryDto was null or undefined when calling createRecipe.');
            }
            const localVarPath = `/recipes/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof newRepositoryDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newRepositoryDto !== undefined ? newRepositoryDto : {}) : (newRepositoryDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new recipe package version
         * @summary Create a new Recipe package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewRecipePackage} newRecipePackage 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipePackage(owner: string, name: string, newRecipePackage: NewRecipePackage, authorization?: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRecipePackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createRecipePackage.');
            }
            // verify required parameter 'newRecipePackage' is not null or undefined
            if (newRecipePackage === null || newRecipePackage === undefined) {
                throw new RequiredError('newRecipePackage','Required parameter newRecipePackage was null or undefined when calling createRecipePackage.');
            }
            const localVarPath = `/recipes/{owner}/{name}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof newRecipePackage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newRecipePackage !== undefined ? newRecipePackage : {}) : (newRecipePackage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a recipe (must have `admin` permission)
         * @summary Delete a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRecipe.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteRecipe.');
            }
            const localVarPath = `/recipes/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipe(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRecipe.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRecipe.');
            }
            const localVarPath = `/recipes/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a recipe tag by name and tag
         * @summary Get a recipe tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTag(owner: string, name: string, tag: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRecipeTag.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRecipeTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getRecipeTag.');
            }
            const localVarPath = `/recipes/{owner}/{name}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTags(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRecipeTags.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRecipeTags.');
            }
            const localVarPath = `/recipes/{owner}/{name}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List recipes
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/recipes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (owner) {
                localVarQueryParameter['owner'] = owner;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (keyword) {
                localVarQueryParameter['keyword'] = keyword;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a recipe (must have `contribute` permission)
         * @summary Update a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRecipe.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateRecipe.');
            }
            // verify required parameter 'updateRepositoryDto' is not null or undefined
            if (updateRepositoryDto === null || updateRepositoryDto === undefined) {
                throw new RequiredError('updateRepositoryDto','Required parameter updateRepositoryDto was null or undefined when calling updateRecipe.');
            }
            const localVarPath = `/recipes/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof updateRepositoryDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateRepositoryDto !== undefined ? updateRepositoryDto : {}) : (updateRepositoryDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipesApi - functional programming interface
 * @export
 * @hidden
 */
export const RecipesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new recipe.
         * @summary Create a Recipe
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(owner: string, newRepositoryDto: NewRepositoryDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).createRecipe(owner, newRepositoryDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new recipe package version
         * @summary Create a new Recipe package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewRecipePackage} newRecipePackage 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipePackage(owner: string, name: string, newRecipePackage: NewRecipePackage, authorization?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).createRecipePackage(owner, name, newRecipePackage, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a recipe (must have `admin` permission)
         * @summary Delete a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).deleteRecipe(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipe(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).getRecipe(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a recipe tag by name and tag
         * @summary Get a recipe tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTag(owner: string, name: string, tag: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).getRecipeTag(owner, name, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTags(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).getRecipeTags(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List recipes
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryListDto> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).listRecipes(page, perPage, name, owner, _public, keyword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a recipe (must have `contribute` permission)
         * @summary Update a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = RecipesApiAxiosParamCreator(configuration).updateRecipe(owner, name, updateRepositoryDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RecipesApi - factory interface
 * @export
 * @hidden
 */
export const RecipesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new recipe.
         * @summary Create a Recipe
         * @param {string} owner 
         * @param {NewRepositoryDto} newRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(owner: string, newRepositoryDto: NewRepositoryDto, options?: any) {
            return RecipesApiFp(configuration).createRecipe(owner, newRepositoryDto, options)(axios, basePath);
        },
        /**
         * Create a new recipe package version
         * @summary Create a new Recipe package
         * @param {string} owner 
         * @param {string} name 
         * @param {NewRecipePackage} newRecipePackage 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipePackage(owner: string, name: string, newRecipePackage: NewRecipePackage, authorization?: string, options?: any) {
            return RecipesApiFp(configuration).createRecipePackage(owner, name, newRecipePackage, authorization, options)(axios, basePath);
        },
        /**
         * Delete a recipe (must have `admin` permission)
         * @summary Delete a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(owner: string, name: string, options?: any) {
            return RecipesApiFp(configuration).deleteRecipe(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipe(owner: string, name: string, options?: any) {
            return RecipesApiFp(configuration).getRecipe(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve a recipe tag by name and tag
         * @summary Get a recipe tag
         * @param {string} owner 
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTag(owner: string, name: string, tag: string, options?: any) {
            return RecipesApiFp(configuration).getRecipeTag(owner, name, tag, options)(axios, basePath);
        },
        /**
         * Retrieve a recipe by name
         * @summary Get a recipe tags
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeTags(owner: string, name: string, options?: any) {
            return RecipesApiFp(configuration).getRecipeTags(owner, name, options)(axios, basePath);
        },
        /**
         * 
         * @summary List recipes
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [keyword] A keyword to index the repository by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any) {
            return RecipesApiFp(configuration).listRecipes(page, perPage, name, owner, _public, keyword, options)(axios, basePath);
        },
        /**
         * Update a recipe (must have `contribute` permission)
         * @summary Update a Recipe
         * @param {string} owner 
         * @param {string} name 
         * @param {UpdateRepositoryDto} updateRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any) {
            return RecipesApiFp(configuration).updateRecipe(owner, name, updateRepositoryDto, options)(axios, basePath);
        },
    };
};

/**
 * RecipesApi - interface
 * @export
 * @interface RecipesApi
 */
export interface RecipesApiInterface {
    /**
     * Create a new recipe.
     * @summary Create a Recipe
     * @param {string} owner 
     * @param {NewRepositoryDto} newRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    createRecipe(owner: string, newRepositoryDto: NewRepositoryDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Create a new recipe package version
     * @summary Create a new Recipe package
     * @param {string} owner 
     * @param {string} name 
     * @param {NewRecipePackage} newRecipePackage 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    createRecipePackage(owner: string, name: string, newRecipePackage: NewRecipePackage, authorization?: string, options?: any): AxiosPromise<object>;

    /**
     * Delete a recipe (must have `admin` permission)
     * @summary Delete a Recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    deleteRecipe(owner: string, name: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a recipe by name
     * @summary Get a recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    getRecipe(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a recipe tag by name and tag
     * @summary Get a recipe tag
     * @param {string} owner 
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    getRecipeTag(owner: string, name: string, tag: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a recipe by name
     * @summary Get a recipe tags
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    getRecipeTags(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary List recipes
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [keyword] A keyword to index the repository by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    listRecipes(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any): AxiosPromise<RepositoryListDto>;

    /**
     * Update a recipe (must have `contribute` permission)
     * @summary Update a Recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {UpdateRepositoryDto} updateRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApiInterface
     */
    updateRecipe(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * RecipesApi - object-oriented interface
 * @export
 * @class RecipesApi
 * @extends {BaseAPI}
 */
export class RecipesApi extends BaseAPI implements RecipesApiInterface {
    /**
     * Create a new recipe.
     * @summary Create a Recipe
     * @param {string} owner 
     * @param {NewRepositoryDto} newRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public createRecipe(owner: string, newRepositoryDto: NewRepositoryDto, options?: any) {
        return RecipesApiFp(this.configuration).createRecipe(owner, newRepositoryDto, options)(this.axios, this.basePath);
    }

    /**
     * Create a new recipe package version
     * @summary Create a new Recipe package
     * @param {string} owner 
     * @param {string} name 
     * @param {NewRecipePackage} newRecipePackage 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public createRecipePackage(owner: string, name: string, newRecipePackage: NewRecipePackage, authorization?: string, options?: any) {
        return RecipesApiFp(this.configuration).createRecipePackage(owner, name, newRecipePackage, authorization, options)(this.axios, this.basePath);
    }

    /**
     * Delete a recipe (must have `admin` permission)
     * @summary Delete a Recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public deleteRecipe(owner: string, name: string, options?: any) {
        return RecipesApiFp(this.configuration).deleteRecipe(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a recipe by name
     * @summary Get a recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipe(owner: string, name: string, options?: any) {
        return RecipesApiFp(this.configuration).getRecipe(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a recipe tag by name and tag
     * @summary Get a recipe tag
     * @param {string} owner 
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipeTag(owner: string, name: string, tag: string, options?: any) {
        return RecipesApiFp(this.configuration).getRecipeTag(owner, name, tag, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a recipe by name
     * @summary Get a recipe tags
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipeTags(owner: string, name: string, options?: any) {
        return RecipesApiFp(this.configuration).getRecipeTags(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List recipes
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [keyword] A keyword to index the repository by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public listRecipes(page?: number, perPage?: number, name?: Array<string>, owner?: Array<string>, _public?: boolean, keyword?: Array<string>, options?: any) {
        return RecipesApiFp(this.configuration).listRecipes(page, perPage, name, owner, _public, keyword, options)(this.axios, this.basePath);
    }

    /**
     * Update a recipe (must have `contribute` permission)
     * @summary Update a Recipe
     * @param {string} owner 
     * @param {string} name 
     * @param {UpdateRepositoryDto} updateRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public updateRecipe(owner: string, name: string, updateRepositoryDto: UpdateRepositoryDto, options?: any) {
        return RecipesApiFp(this.configuration).updateRecipe(owner, name, updateRepositoryDto, options)(this.axios, this.basePath);
    }

}


/**
 * RegistriesApi - axios parameter creator
 * @export
 * @hidden
 */
export const RegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Package
         * @param {string} owner 
         * @param {string} type 
         * @param {string} name 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(owner: string, type: string, name: string, digest: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getPackage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getPackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackage.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling getPackage.');
            }
            const localVarPath = `/registries/{owner}/{type}/{name}/{digest}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Registry Index
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryIndex(owner: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRegistryIndex.');
            }
            const localVarPath = `/registries/{owner}/index.json`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Push an Operator to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperator(owner: string, _package: any, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling postOperator.');
            }
            // verify required parameter '_package' is not null or undefined
            if (_package === null || _package === undefined) {
                throw new RequiredError('_package','Required parameter _package was null or undefined when calling postOperator.');
            }
            const localVarPath = `/registries/{owner}/operators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (_package !== undefined) { 
                localVarFormParams.append('package', _package as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Push an Recipe to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRecipe(owner: string, _package: any, authorization?: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling postRecipe.');
            }
            // verify required parameter '_package' is not null or undefined
            if (_package === null || _package === undefined) {
                throw new RequiredError('_package','Required parameter _package was null or undefined when calling postRecipe.');
            }
            const localVarPath = `/registries/{owner}/recipes`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


            if (_package !== undefined) { 
                localVarFormParams.append('package', _package as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistriesApi - functional programming interface
 * @export
 * @hidden
 */
export const RegistriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Package
         * @param {string} owner 
         * @param {string} type 
         * @param {string} name 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(owner: string, type: string, name: string, digest: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = RegistriesApiAxiosParamCreator(configuration).getPackage(owner, type, name, digest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Registry Index
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryIndex(owner: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryIndex> {
            const localVarAxiosArgs = RegistriesApiAxiosParamCreator(configuration).getRegistryIndex(owner, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Push an Operator to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperator(owner: string, _package: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RegistriesApiAxiosParamCreator(configuration).postOperator(owner, _package, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Push an Recipe to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRecipe(owner: string, _package: any, authorization?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RegistriesApiAxiosParamCreator(configuration).postRecipe(owner, _package, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RegistriesApi - factory interface
 * @export
 * @hidden
 */
export const RegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Package
         * @param {string} owner 
         * @param {string} type 
         * @param {string} name 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(owner: string, type: string, name: string, digest: string, options?: any) {
            return RegistriesApiFp(configuration).getPackage(owner, type, name, digest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get Registry Index
         * @param {string} owner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryIndex(owner: string, options?: any) {
            return RegistriesApiFp(configuration).getRegistryIndex(owner, options)(axios, basePath);
        },
        /**
         * 
         * @summary Push an Operator to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperator(owner: string, _package: any, options?: any) {
            return RegistriesApiFp(configuration).postOperator(owner, _package, options)(axios, basePath);
        },
        /**
         * 
         * @summary Push an Recipe to the registry
         * @param {string} owner 
         * @param {any} _package 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRecipe(owner: string, _package: any, authorization?: string, options?: any) {
            return RegistriesApiFp(configuration).postRecipe(owner, _package, authorization, options)(axios, basePath);
        },
    };
};

/**
 * RegistriesApi - interface
 * @export
 * @interface RegistriesApi
 */
export interface RegistriesApiInterface {
    /**
     * 
     * @summary Get Package
     * @param {string} owner 
     * @param {string} type 
     * @param {string} name 
     * @param {string} digest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApiInterface
     */
    getPackage(owner: string, type: string, name: string, digest: string, options?: any): AxiosPromise<{}>;

    /**
     * 
     * @summary Get Registry Index
     * @param {string} owner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApiInterface
     */
    getRegistryIndex(owner: string, options?: any): AxiosPromise<RepositoryIndex>;

    /**
     * 
     * @summary Push an Operator to the registry
     * @param {string} owner 
     * @param {any} _package 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApiInterface
     */
    postOperator(owner: string, _package: any, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Push an Recipe to the registry
     * @param {string} owner 
     * @param {any} _package 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApiInterface
     */
    postRecipe(owner: string, _package: any, authorization?: string, options?: any): AxiosPromise<object>;

}

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI implements RegistriesApiInterface {
    /**
     * 
     * @summary Get Package
     * @param {string} owner 
     * @param {string} type 
     * @param {string} name 
     * @param {string} digest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public getPackage(owner: string, type: string, name: string, digest: string, options?: any) {
        return RegistriesApiFp(this.configuration).getPackage(owner, type, name, digest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get Registry Index
     * @param {string} owner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public getRegistryIndex(owner: string, options?: any) {
        return RegistriesApiFp(this.configuration).getRegistryIndex(owner, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Push an Operator to the registry
     * @param {string} owner 
     * @param {any} _package 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public postOperator(owner: string, _package: any, options?: any) {
        return RegistriesApiFp(this.configuration).postOperator(owner, _package, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Push an Recipe to the registry
     * @param {string} owner 
     * @param {any} _package 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public postRecipe(owner: string, _package: any, authorization?: string, options?: any) {
        return RegistriesApiFp(this.configuration).postRecipe(owner, _package, authorization, options)(this.axios, this.basePath);
    }

}


/**
 * SimulationsApi - axios parameter creator
 * @export
 * @hidden
 */
export const SimulationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, authorization?: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createSimulation.');
            }
            // verify required parameter 'submitSimulationDto' is not null or undefined
            if (submitSimulationDto === null || submitSimulationDto === undefined) {
                throw new RequiredError('submitSimulationDto','Required parameter submitSimulationDto was null or undefined when calling createSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof submitSimulationDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(submitSimulationDto !== undefined ? submitSimulationDto : {}) : (submitSimulationDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationInputs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationInputs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationInputs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/inputs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationLogs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationLogs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/logs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationOutputs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationOutputs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationOutputs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/outputs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getSimulationTaskLogs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/task/{task_id}/logs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, status?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSimulations.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listSimulations.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resumeSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling resumeSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling suspendSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling suspendSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling suspendSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/suspend`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationsApi - functional programming interface
 * @export
 * @hidden
 */
export const SimulationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, authorization?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).createSimulation(owner, name, submitSimulationDto, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationStatus> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationInputs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationLogs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationOutputs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, status?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationList> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).listSimulations(owner, name, page, perPage, id, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).resumeSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).suspendSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SimulationsApi - factory interface
 * @export
 * @hidden
 */
export const SimulationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, authorization?: string, options?: any) {
            return SimulationsApiFp(configuration).createSimulation(owner, name, submitSimulationDto, authorization, options)(axios, basePath);
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulation(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationInputs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationLogs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationOutputs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options)(axios, basePath);
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, status?: Array<string>, options?: any) {
            return SimulationsApiFp(configuration).listSimulations(owner, name, page, perPage, id, status, options)(axios, basePath);
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).resumeSimulation(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).suspendSimulation(owner, name, simulationId, options)(axios, basePath);
        },
    };
};

/**
 * SimulationsApi - interface
 * @export
 * @interface SimulationsApi
 */
export interface SimulationsApiInterface {
    /**
     * Create a new simulation.
     * @summary Schedule a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {SubmitSimulationDto} submitSimulationDto 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, authorization?: string, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Retrieve a simulation.
     * @summary Get a Simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<SimulationStatus>;

    /**
     * get simulation inputs
     * @summary Get simulation inputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationInputs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation logs
     * @summary Get simulation logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationLogs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation outputs
     * @summary Get simulation outputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation task logs
     * @summary Get a simulation task\'s logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any): AxiosPromise<string>;

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a simulation to search for
     * @param {Array<string>} [status] The status of the simulation to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, status?: Array<string>, options?: any): AxiosPromise<SimulationList>;

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    resumeSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<Accepted>;

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    suspendSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<Accepted>;

}

/**
 * SimulationsApi - object-oriented interface
 * @export
 * @class SimulationsApi
 * @extends {BaseAPI}
 */
export class SimulationsApi extends BaseAPI implements SimulationsApiInterface {
    /**
     * Create a new simulation.
     * @summary Schedule a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {SubmitSimulationDto} submitSimulationDto 
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, authorization?: string, options?: any) {
        return SimulationsApiFp(this.configuration).createSimulation(owner, name, submitSimulationDto, authorization, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a simulation.
     * @summary Get a Simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation inputs
     * @summary Get simulation inputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationInputs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationInputs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation logs
     * @summary Get simulation logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationLogs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationLogs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation outputs
     * @summary Get simulation outputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationOutputs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation task logs
     * @summary Get a simulation task\'s logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a simulation to search for
     * @param {Array<string>} [status] The status of the simulation to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, status?: Array<string>, options?: any) {
        return SimulationsApiFp(this.configuration).listSimulations(owner, name, page, perPage, id, status, options)(this.axios, this.basePath);
    }

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public resumeSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).resumeSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public suspendSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).suspendSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

}


/**
 * TeamsApi - axios parameter creator
 * @export
 * @hidden
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling createTeam.');
            }
            // verify required parameter 'patchTeamDto' is not null or undefined
            if (patchTeamDto === null || patchTeamDto === undefined) {
                throw new RequiredError('patchTeamDto','Required parameter patchTeamDto was null or undefined when calling createTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchTeamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchTeamDto !== undefined ? patchTeamDto : {}) : (patchTeamDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling deleteOrgTeamMember.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling deleteOrgTeamMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteOrgTeamMember.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members/{username}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling getOrgTeamMembers.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling getOrgTeamMembers.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling getTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling getTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling listOrgTeams.');
            }
            const localVarPath = `/orgs/{org_name}/teams`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (member) {
                localVarQueryParameter['member'] = member;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'patchTeamDto' is not null or undefined
            if (patchTeamDto === null || patchTeamDto === undefined) {
                throw new RequiredError('patchTeamDto','Required parameter patchTeamDto was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchTeamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchTeamDto !== undefined ? patchTeamDto : {}) : (patchTeamDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling upsertOrgTeamMember.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members/{username}/{role}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 * @hidden
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).createTeam(orgName, patchTeamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).deleteOrgTeamMember(orgName, teamSlug, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).deleteTeam(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMemberDto>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getOrgTeamMembers(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getTeam(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).listOrgTeams(orgName, page, perPage, name, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).updateTeam(orgName, teamSlug, patchTeamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 * @hidden
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any) {
            return TeamsApiFp(configuration).createTeam(orgName, patchTeamDto, options)(axios, basePath);
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any) {
            return TeamsApiFp(configuration).deleteOrgTeamMember(orgName, teamSlug, username, options)(axios, basePath);
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).deleteTeam(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).getOrgTeamMembers(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).getTeam(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
            return TeamsApiFp(configuration).listOrgTeams(orgName, page, perPage, name, member, options)(axios, basePath);
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any) {
            return TeamsApiFp(configuration).updateTeam(orgName, teamSlug, patchTeamDto, options)(axios, basePath);
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any) {
            return TeamsApiFp(configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options)(axios, basePath);
        },
    };
};

/**
 * TeamsApi - interface
 * @export
 * @interface TeamsApi
 */
export interface TeamsApiInterface {
    /**
     * Create a new team (must be parent org member)
     * @summary Create a Team
     * @param {string} orgName 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove a team member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a team (must have team or org `owner` role)
     * @summary Delete a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    deleteTeam(orgName: string, teamSlug: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a tean\'s members
     * @summary List a team\'s members
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    getOrgTeamMembers(orgName: string, teamSlug: string, options?: any): AxiosPromise<Array<TeamMemberDto>>;

    /**
     * Retrieve a team by name
     * @summary Get a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    getTeam(orgName: string, teamSlug: string, options?: any): AxiosPromise<object>;

    /**
     * search for orgs using query parameters
     * @summary List Teams
     * @param {string} orgName 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): AxiosPromise<Array<TeamDto>>;

    /**
     * Update a team (must have team or org `owner` role)
     * @summary Update a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a member role to the team (must have org or team `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI implements TeamsApiInterface {
    /**
     * Create a new team (must be parent org member)
     * @summary Create a Team
     * @param {string} orgName 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any) {
        return TeamsApiFp(this.configuration).createTeam(orgName, patchTeamDto, options)(this.axios, this.basePath);
    }

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove a team member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any) {
        return TeamsApiFp(this.configuration).deleteOrgTeamMember(orgName, teamSlug, username, options)(this.axios, this.basePath);
    }

    /**
     * Delete a team (must have team or org `owner` role)
     * @summary Delete a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).deleteTeam(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a tean\'s members
     * @summary List a team\'s members
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getOrgTeamMembers(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).getOrgTeamMembers(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a team by name
     * @summary Get a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeam(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).getTeam(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * search for orgs using query parameters
     * @summary List Teams
     * @param {string} orgName 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
        return TeamsApiFp(this.configuration).listOrgTeams(orgName, page, perPage, name, member, options)(this.axios, this.basePath);
    }

    /**
     * Update a team (must have team or org `owner` role)
     * @summary Update a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any) {
        return TeamsApiFp(this.configuration).updateTeam(orgName, teamSlug, patchTeamDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a member role to the team (must have org or team `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any) {
        return TeamsApiFp(this.configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options)(this.axios, this.basePath);
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 * @hidden
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options: any = {}): RequestArgs {
            // verify required parameter 'emailRequest' is not null or undefined
            if (emailRequest === null || emailRequest === undefined) {
                throw new RequiredError('emailRequest','Required parameter emailRequest was null or undefined when calling changePassword.');
            }
            const localVarPath = `/user/change_password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof emailRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(emailRequest !== undefined ? emailRequest : {}) : (emailRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options: any = {}): RequestArgs {
            const localVarPath = `/user/roles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options: any = {}): RequestArgs {
            const localVarPath = `/user/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options: any = {}): RequestArgs {
            // verify required parameter 'loginDto' is not null or undefined
            if (loginDto === null || loginDto === undefined) {
                throw new RequiredError('loginDto','Required parameter loginDto was null or undefined when calling login.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof loginDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(loginDto !== undefined ? loginDto : {}) : (loginDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options: any = {}): RequestArgs {
            // verify required parameter 'signUpDto' is not null or undefined
            if (signUpDto === null || signUpDto === undefined) {
                throw new RequiredError('signUpDto','Required parameter signUpDto was null or undefined when calling signup.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof signUpDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUpDto !== undefined ? signUpDto : {}) : (signUpDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options: any = {}): RequestArgs {
            // verify required parameter 'createTokenDto' is not null or undefined
            if (createTokenDto === null || createTokenDto === undefined) {
                throw new RequiredError('createTokenDto','Required parameter createTokenDto was null or undefined when calling upsertRefreshToken.');
            }
            const localVarPath = `/user/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createTokenDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTokenDto !== undefined ? createTokenDto : {}) : (createTokenDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 * @hidden
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).changePassword(emailRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateUserDto> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getMe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshTokenDto>> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).listRefreshTokens(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginToken> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).login(loginDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).signup(signUpDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).upsertRefreshToken(createTokenDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 * @hidden
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options?: any) {
            return UserApiFp(configuration).changePassword(emailRequest, options)(axios, basePath);
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any) {
            return UserApiFp(configuration).getMe(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any) {
            return UserApiFp(configuration).getRoles(options)(axios, basePath);
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options?: any) {
            return UserApiFp(configuration).listRefreshTokens(options)(axios, basePath);
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any) {
            return UserApiFp(configuration).login(loginDto, options)(axios, basePath);
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options?: any) {
            return UserApiFp(configuration).signup(signUpDto, options)(axios, basePath);
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any) {
            return UserApiFp(configuration).upsertRefreshToken(createTokenDto, options)(axios, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Make a password change request
     * @summary Make a password change request
     * @param {EmailRequest} emailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    changePassword(emailRequest: EmailRequest, options?: any): AxiosPromise<object>;

    /**
     * Get authenticated user profile
     * @summary Get authenticated user profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getMe(options?: any): AxiosPromise<PrivateUserDto>;

    /**
     * 
     * @summary Get the authenticated user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getRoles(options?: any): AxiosPromise<Array<string>>;

    /**
     * Get a list of token names
     * @summary Get a list of token names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listRefreshTokens(options?: any): AxiosPromise<Array<RefreshTokenDto>>;

    /**
     * Login a user
     * @summary Login to the platform and get a JWT back
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    login(loginDto: LoginDto, options?: any): AxiosPromise<LoginToken>;

    /**
     * Sign Up a new user
     * @summary Sign Up to the platform!
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    signup(signUpDto: SignUpDto, options?: any): AxiosPromise<object>;

    /**
     * Get refresh token and delete previous one if it exists
     * @summary Get refresh token and delete previous one if it exists
     * @param {CreateTokenDto} createTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any): AxiosPromise<string>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Make a password change request
     * @summary Make a password change request
     * @param {EmailRequest} emailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePassword(emailRequest: EmailRequest, options?: any) {
        return UserApiFp(this.configuration).changePassword(emailRequest, options)(this.axios, this.basePath);
    }

    /**
     * Get authenticated user profile
     * @summary Get authenticated user profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: any) {
        return UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get the authenticated user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getRoles(options?: any) {
        return UserApiFp(this.configuration).getRoles(options)(this.axios, this.basePath);
    }

    /**
     * Get a list of token names
     * @summary Get a list of token names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listRefreshTokens(options?: any) {
        return UserApiFp(this.configuration).listRefreshTokens(options)(this.axios, this.basePath);
    }

    /**
     * Login a user
     * @summary Login to the platform and get a JWT back
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginDto: LoginDto, options?: any) {
        return UserApiFp(this.configuration).login(loginDto, options)(this.axios, this.basePath);
    }

    /**
     * Sign Up a new user
     * @summary Sign Up to the platform!
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public signup(signUpDto: SignUpDto, options?: any) {
        return UserApiFp(this.configuration).signup(signUpDto, options)(this.axios, this.basePath);
    }

    /**
     * Get refresh token and delete previous one if it exists
     * @summary Get refresh token and delete previous one if it exists
     * @param {CreateTokenDto} createTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any) {
        return UserApiFp(this.configuration).upsertRefreshToken(createTokenDto, options)(this.axios, this.basePath);
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 * @hidden
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options: any = {}): RequestArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling checkUsername.');
            }
            const localVarPath = `/users/check_username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOneUser.');
            }
            const localVarPath = `/users/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 * @hidden
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).checkUsername(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUserDto> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getOneUser(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicUserDto>> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).listUsers(page, perPage, name, username, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 * @hidden
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options?: any) {
            return UsersApiFp(configuration).checkUsername(username, options)(axios, basePath);
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options?: any) {
            return UsersApiFp(configuration).getOneUser(name, options)(axios, basePath);
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any) {
            return UsersApiFp(configuration).listUsers(page, perPage, name, username, id, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Check if a username is already taken by a user or an org
     * @summary Check if a username is already taken
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    checkUsername(username: string, options?: any): AxiosPromise<object>;

    /**
     * Get a specific user profile by name
     * @summary Get a specific user profile
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getOneUser(name: string, options?: any): AxiosPromise<PublicUserDto>;

    /**
     * 
     * @summary List Users
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {string} [name] Name of the user to search for
     * @param {string} [username] Username of the user to search for
     * @param {Array<string>} [id] A list of users to search for by their user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any): AxiosPromise<Array<PublicUserDto>>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Check if a username is already taken by a user or an org
     * @summary Check if a username is already taken
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkUsername(username: string, options?: any) {
        return UsersApiFp(this.configuration).checkUsername(username, options)(this.axios, this.basePath);
    }

    /**
     * Get a specific user profile by name
     * @summary Get a specific user profile
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOneUser(name: string, options?: any) {
        return UsersApiFp(this.configuration).getOneUser(name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List Users
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {string} [name] Name of the user to search for
     * @param {string} [username] Username of the user to search for
     * @param {Array<string>} [id] A list of users to search for by their user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).listUsers(page, perPage, name, username, id, options)(this.axios, this.basePath);
    }

}


