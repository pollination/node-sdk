// tslint:disable
/**
 * pollination.cloud
 * Pollination Cloud API
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Accepted request response.
 * @export
 * @interface Accepted
 */
export interface Accepted {
    /**
     * Url to access the requested resource.
     * @type {string}
     * @memberof Accepted
     */
    url: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof Accepted
     */
    message?: string;
}
/**
 * Aperture Schema
 * @export
 * @interface Aperture
 */
export interface Aperture {
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof Aperture
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Aperture
     */
    name: string;
    /**
     * 
     * @type {Array<Vertex>}
     * @memberof Aperture
     */
    vertices: Array<Vertex>;
    /**
     * 
     * @type {string}
     * @memberof Aperture
     */
    faceType: ApertureFaceTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof Aperture
     */
    radModifier?: object;
    /**
     * 
     * @type {object}
     * @memberof Aperture
     */
    radModifierDir?: object;
    /**
     * 
     * @type {string}
     * @memberof Aperture
     */
    type: ApertureTypeEnum;
    /**
     * 
     * @type {Array<ShadeFace>}
     * @memberof Aperture
     */
    blinds?: Array<ShadeFace>;
}

/**
    * @export
    * @enum {string}
    */
export enum ApertureFaceTypeEnum {
    Window = 'Window'
}
/**
    * @export
    * @enum {string}
    */
export enum ApertureTypeEnum {
    Aperture = 'Aperture'
}

/**
 * Local application.
 * @export
 * @interface App
 */
export interface App {
    /**
     * App name
     * @type {string}
     * @memberof App
     */
    name: string;
    /**
     * App version requirements. For instance >=5.2
     * @type {string}
     * @memberof App
     */
    version?: string;
    /**
     * A command to check if application is installed
     * @type {string}
     * @memberof App
     */
    command: string;
    /**
     * An optional regex pattern to apply to command output.
     * @type {string}
     * @memberof App
     */
    pattern?: string;
}
/**
 * Arguments to a task or a workflow.  Queenbee accepts two types of arguments: parameters and artifacts. A ``parameter`` is a variable that can be passed to a task or a workflow. An ``artifact`` is a file or folder that can be identified by a url or a path.
 * @export
 * @interface Arguments
 */
export interface Arguments {
    /**
     * Parameters is the list of input parameters to pass to the task or workflow. A parameter can have a default value which will be overwritten if an input value is provided.
     * @type {Array<Parameter>}
     * @memberof Arguments
     */
    parameters?: Array<Parameter>;
    /**
     * Artifacts is the list of file and folder arguments to pass to the task or workflow.
     * @type {Array<Artifact>}
     * @memberof Arguments
     */
    artifacts?: Array<Artifact>;
}
/**
 * Artifact indicates an artifact to place at a specified path
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * name of the artifact. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof Artifact
     */
    name: string;
    /**
     * Name of the Artifact Location to source this artifact from.
     * @type {string}
     * @memberof Artifact
     */
    location?: string;
    /**
     * Path to the artifact on the local machine, url or S3 bucket.
     * @type {string}
     * @memberof Artifact
     */
    sourcePath?: string;
    /**
     * Path the artifact should be copied to in the temporary task folder.
     * @type {string}
     * @memberof Artifact
     */
    path?: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof Artifact
     */
    description?: string;
    /**
     * An object with Key Value pairs of HTTP headers. For artifacts from URL Location only
     * @type {{ [key: string]: string; }}
     * @memberof Artifact
     */
    headers?: { [key: string]: string; };
    /**
     * The HTTP verb to use when making the request. For artifacts from URL Location only
     * @type {string}
     * @memberof Artifact
     */
    verb?: ArtifactVerbEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVerbEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * 
 * @export
 * @interface Auth0TokenResponse
 */
export interface Auth0TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof Auth0TokenResponse
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof Auth0TokenResponse
     */
    tokenType: string;
    /**
     * 
     * @type {number}
     * @memberof Auth0TokenResponse
     */
    expiresIn: number;
}
/**
 * Content for created response.
 * @export
 * @interface CreatedContent
 */
export interface CreatedContent {
    /**
     * Id for the newly created resource.
     * @type {string}
     * @memberof CreatedContent
     */
    id: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof CreatedContent
     */
    message?: string;
}
/**
 * DAG includes different steps of a directed acyclic graph.
 * @export
 * @interface DAG
 */
export interface DAG {
    /**
     * A unique name for this dag.
     * @type {string}
     * @memberof DAG
     */
    name: string;
    /**
     * Target are one or more names of target tasks to execute in a DAG. Multiple targets can be specified as space delimited inputs. When a target is provided only a subset of tasks in DAG that are required to generate the target(s) will be executed.
     * @type {string}
     * @memberof DAG
     */
    target?: string;
    /**
     * Stop scheduling new steps, as soon as it detects that one of the DAG nodes is failed. Default is True.
     * @type {boolean}
     * @memberof DAG
     */
    failFast?: boolean;
    /**
     * Tasks are a list of DAG steps
     * @type {Array<DAGTask>}
     * @memberof DAG
     */
    tasks: Array<DAGTask>;
}
/**
 * DAGTask defines a single step in a Directed Acyclic Graph (DAG) workflow.
 * @export
 * @interface DAGTask
 */
export interface DAGTask {
    /**
     * Name for this step. It must be unique in DAG.
     * @type {string}
     * @memberof DAGTask
     */
    name: string;
    /**
     * Input arguments for template.
     * @type {Arguments}
     * @memberof DAGTask
     */
    arguments?: Arguments;
    /**
     * Template name.
     * @type {string}
     * @memberof DAGTask
     */
    template: string;
    /**
     * Dependencies are name of other DAG steps which this depends on.
     * @type {Array<string>}
     * @memberof DAGTask
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof DAGTask
     */
    loop?: object;
    /**
     * Control parameters for loop.
     * @type {LoopControl}
     * @memberof DAGTask
     */
    loopControl?: LoopControl;
}
/**
 * A single model face.      Some clever description
 * @export
 * @interface Face
 */
export interface Face {
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof Face
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Face
     */
    name: string;
    /**
     * 
     * @type {Array<Vertex>}
     * @memberof Face
     */
    vertices: Array<Vertex>;
    /**
     * 
     * @type {string}
     * @memberof Face
     */
    faceType?: FaceFaceTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof Face
     */
    radModifier?: object;
    /**
     * 
     * @type {object}
     * @memberof Face
     */
    radModifierDir?: object;
    /**
     * 
     * @type {string}
     * @memberof Face
     */
    type: FaceTypeEnum;
    /**
     * List of Apertures bound to the Face
     * @type {Array<Aperture>}
     * @memberof Face
     */
    apertures?: Array<Aperture>;
    /**
     * 
     * @type {Parent}
     * @memberof Face
     */
    parent?: Parent;
}

/**
    * @export
    * @enum {string}
    */
export enum FaceFaceTypeEnum {
    Wall = 'Wall',
    RoofCeiling = 'RoofCeiling',
    Floor = 'Floor',
    AirWall = 'AirWall',
    Shading = 'Shading'
}
/**
    * @export
    * @enum {string}
    */
export enum FaceTypeEnum {
    Face = 'Face'
}

/**
 * A function with a single command.
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    type: string;
    /**
     * Function name. Must be unique within a workflow.
     * @type {string}
     * @memberof Function
     */
    name: string;
    /**
     * Function description. A short human readable description for this function.
     * @type {string}
     * @memberof Function
     */
    description?: string;
    /**
     * Input arguments for this function.
     * @type {Arguments}
     * @memberof Function
     */
    inputs?: Arguments;
    /**
     * Full shell command for this function. Each function accepts only one command. The command will be executed as a shell command in operator. For running several commands after each other use && between the commands or pipe data from one to another using |
     * @type {string}
     * @memberof Function
     */
    command: string;
    /**
     * Function operator name.
     * @type {string}
     * @memberof Function
     */
    operator: string;
    /**
     * A dictionary of key:values for environmental variables.
     * @type {{ [key: string]: string; }}
     * @memberof Function
     */
    env?: { [key: string]: string; };
    /**
     * List of output arguments.
     * @type {Arguments}
     * @memberof Function
     */
    outputs?: Arguments;
}
/**
 * Glass Material Schema
 * @export
 * @interface Glass
 */
export interface Glass {
    /**
     * 
     * @type {string}
     * @memberof Glass
     */
    type: GlassTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Glass
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Glass
     */
    rTransmittance: number;
    /**
     * 
     * @type {number}
     * @memberof Glass
     */
    gTransmittance: number;
    /**
     * 
     * @type {number}
     * @memberof Glass
     */
    bTransmittance: number;
    /**
     * 
     * @type {number}
     * @memberof Glass
     */
    refractionIndex: number;
    /**
     * 
     * @type {string}
     * @memberof Glass
     */
    modifier?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum GlassTypeEnum {
    Glass = 'Glass'
}

/**
 * HTTPLocation  A web HTTP to an FTP server or an API for example.
 * @export
 * @interface HTTPLocation
 */
export interface HTTPLocation {
    /**
     * 
     * @type {string}
     * @memberof HTTPLocation
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof HTTPLocation
     */
    name: string;
    /**
     * For a HTTP endpoint this can be http://climate.onebuilding.org.
     * @type {string}
     * @memberof HTTPLocation
     */
    root: string;
    /**
     * An object with Key Value pairs of HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof HTTPLocation
     */
    headers?: { [key: string]: string; };
    /**
     * The HTTP verb to use when making the request.
     * @type {string}
     * @memberof HTTPLocation
     */
    verb?: HTTPLocationVerbEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HTTPLocationVerbEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * KeySecret
 * @export
 * @interface KeySecret
 */
export interface KeySecret {
    /**
     * 
     * @type {string}
     * @memberof KeySecret
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof KeySecret
     */
    key: string;
}
/**
 * Required programming language.
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * Language name
     * @type {string}
     * @memberof Language
     */
    name?: string;
    /**
     * Language version requirements. For instance ==3.7 or >=3.6
     * @type {string}
     * @memberof Language
     */
    version?: string;
}
/**
 * Local Location  A folder on a machine\'s file system. This machine is the one where the workflow is running.
 * @export
 * @interface LocalLocation
 */
export interface LocalLocation {
    /**
     * 
     * @type {string}
     * @memberof LocalLocation
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof LocalLocation
     */
    name: string;
    /**
     * For a local filesystem this can be \"C:\\Users\\me\\simulations\\test\".
     * @type {string}
     * @memberof LocalLocation
     */
    root: string;
}
/**
 * Operator requirements for local runs.
 * @export
 * @interface LocalRequirements
 */
export interface LocalRequirements {
    /**
     * 
     * @type {string}
     * @memberof LocalRequirements
     */
    type?: string;
    /**
     * List of valid platforms that operator can execute the commands.
     * @type {Array<string>}
     * @memberof LocalRequirements
     */
    platform?: Array<string>;
    /**
     * List of required programming languages to execute the commands with an operator.
     * @type {Array<Language>}
     * @memberof LocalRequirements
     */
    language?: Array<Language>;
    /**
     * List of applications that are required for operator to execute the commands locally. You must follow pip requirement specifiers: https://pip.pypa.io/en/stable/reference/pip_install/#requirement-specifiers For instance use rtrace>=5.2 for radiance 5.2 or newer. Command will run  rtrace --version and tries to parse version from command.
     * @type {Array<App>}
     * @memberof LocalRequirements
     */
    app?: Array<App>;
    /**
     * List of Python packages that are required for operator to execute the commands locally. You must follow pip requirement specifiers: https://pip.pypa.io/en/stable/reference/pip_install/#requirement-specifiers
     * @type {Array<Package>}
     * @memberof LocalRequirements
     */
    pip?: Array<Package>;
    /**
     * List of npm packages that are required for operator to execute the commands locally. You must follow npm install requirements: https://docs.npmjs.com/cli/install#synopsis
     * @type {Array<Package>}
     * @memberof LocalRequirements
     */
    npm?: Array<Package>;
}
/**
 * Control object for loops.
 * @export
 * @interface LoopControl
 */
export interface LoopControl {
    /**
     * Name of variable which will be referenced in task.
     * @type {string}
     * @memberof LoopControl
     */
    loopVar?: string;
    /**
     * Number of seconds to pause between the loops.
     * @type {number}
     * @memberof LoopControl
     */
    pause?: number;
    /**
     * Iterable object type: list | object
     * @type {string}
     * @memberof LoopControl
     */
    iterableType?: string;
    /**
     * A switch to indicate if loops should be executed in serial or parallel.
     * @type {boolean}
     * @memberof LoopControl
     */
    parallel?: boolean;
}
/**
 * Face by Face Model Schema
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    type: ModelTypeEnum;
    /**
     * Model name
     * @type {string}
     * @memberof Model
     */
    name: string;
    /**
     * Value to use to convert the current model into meters
     * @type {number}
     * @memberof Model
     */
    convertToMeters?: number;
    /**
     * List of model faces, can be of type Face or ShadeFace
     * @type {Array<object>}
     * @memberof Model
     */
    faces?: Array<object>;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelTypeEnum {
    Model = 'Model'
}

/**
 * Face by Face Model Schema
 * @export
 * @interface Model1
 */
export interface Model1 {
    /**
     * 
     * @type {string}
     * @memberof Model1
     */
    type: Model1TypeEnum;
    /**
     * Model name
     * @type {string}
     * @memberof Model1
     */
    name: string;
    /**
     * Value to use to convert the current model into meters
     * @type {number}
     * @memberof Model1
     */
    convertToMeters?: number;
    /**
     * List of model faces, can be of type Face or ShadeFace
     * @type {Array<object>}
     * @memberof Model1
     */
    faces?: Array<object>;
}

/**
    * @export
    * @enum {string}
    */
export enum Model1TypeEnum {
    Model = 'Model'
}

/**
 * Face by Face Model Schema Out
 * @export
 * @interface ModelOut
 */
export interface ModelOut {
    /**
     * 
     * @type {string}
     * @memberof ModelOut
     */
    type: ModelOutTypeEnum;
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof ModelOut
     */
    id?: string;
    /**
     * Model name
     * @type {string}
     * @memberof ModelOut
     */
    name: string;
    /**
     * Value to use to convert the current model into meters
     * @type {number}
     * @memberof ModelOut
     */
    convertToMeters?: number;
    /**
     * Number of faces attached to this model
     * @type {number}
     * @memberof ModelOut
     */
    faceCount: number;
    /**
     * Model creation time.
     * @type {Date}
     * @memberof ModelOut
     */
    createdAt: Date;
    /**
     * URL to the model
     * @type {string}
     * @memberof ModelOut
     */
    url: string;
    /**
     * URL to get faces from this model.
     * @type {string}
     * @memberof ModelOut
     */
    facesUrl: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelOutTypeEnum {
    Model = 'Model'
}

/**
 * 
 * @export
 * @interface NewToken
 */
export interface NewToken {
    /**
     * 
     * @type {string}
     * @memberof NewToken
     */
    id: string;
}
/**
 * An argo task node status object
 * @export
 * @interface NodeStatus
 */
export interface NodeStatus {
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    templateName?: string;
    /**
     * 
     * @type {TemplateRef}
     * @memberof NodeStatus
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    storedTemplateID?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    workflowTemplateName?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    phase?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    boundaryID?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof NodeStatus
     */
    startedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NodeStatus
     */
    finishedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    podIP?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    daemoned?: string;
    /**
     * 
     * @type {QueenbeeArgoSchemaArgumentsArguments}
     * @memberof NodeStatus
     */
    inputs?: QueenbeeArgoSchemaArgumentsArguments;
    /**
     * 
     * @type {Outputs}
     * @memberof NodeStatus
     */
    outputs?: Outputs;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeStatus
     */
    children?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeStatus
     */
    outboundNodes?: Array<string>;
}
/**
 * Opaque Material Schema
 * @export
 * @interface Opaque
 */
export interface Opaque {
    /**
     * 
     * @type {string}
     * @memberof Opaque
     */
    type: OpaqueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Opaque
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Opaque
     */
    reflectance: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OpaqueTypeEnum {
    Opaque = 'Opaque'
}

/**
 * Task operator.  A task operator includes the information for executing tasks from command line or in a container.
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    type?: string;
    /**
     * Operator name. This name should be unique among all the operators in your workflow.
     * @type {string}
     * @memberof Operator
     */
    name: string;
    /**
     * Optional version input for operator.
     * @type {string}
     * @memberof Operator
     */
    version?: string;
    /**
     * Docker image name.
     * @type {string}
     * @memberof Operator
     */
    image: string;
    /**
     * An optional requirement object to specify requirements for local execution of the commands.
     * @type {LocalRequirements}
     * @memberof Operator
     */
    local?: LocalRequirements;
}
/**
 * Arguments to a task or a workflow.  Queenbee accepts two types of arguments: parameters and artifacts. A ``parameter`` is a variable that can be passed to a task or a workflow. An ``artifact`` is a file or folder that can be identified by a url or a path.
 * @export
 * @interface Outputs
 */
export interface Outputs {
    /**
     * Parameters is the list of input parameters to pass to the task or workflow. A parameter can have a default value which will be overwritten if an input value is provided.
     * @type {Array<QueenbeeArgoSchemaArgumentsParameter>}
     * @memberof Outputs
     */
    parameters?: Array<QueenbeeArgoSchemaArgumentsParameter>;
    /**
     * Artifacts is the list of file and folder arguments to pass to the task or workflow.
     * @type {Array<QueenbeeArgoSchemaArgumentsArtifact>}
     * @memberof Outputs
     */
    artifacts?: Array<QueenbeeArgoSchemaArgumentsArtifact>;
    /**
     * 
     * @type {string}
     * @memberof Outputs
     */
    result?: string;
}
/**
 * A distribution package.
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * Package name
     * @type {string}
     * @memberof Package
     */
    name: string;
    /**
     * Package version requirements. For instance ==3.7 or >=3.6
     * @type {string}
     * @memberof Package
     */
    version?: string;
}
/**
 * Parameter.  Parameter indicate a passed string parameter to a service template with an optional default value.
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof Parameter
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {object}
     * @memberof Parameter
     */
    value?: object;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof Parameter
     */
    description?: string;
    /**
     * load parameters from a file. File can be a JSON / YAML or a text file.
     * @type {string}
     * @memberof Parameter
     */
    path?: string;
}
/**
 * Parent zone information
 * @export
 * @interface Parent
 */
export interface Parent {
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof Parent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Parent
     */
    name: string;
}
/**
 * Plastic Material Schema
 * @export
 * @interface Plastic
 */
export interface Plastic {
    /**
     * 
     * @type {string}
     * @memberof Plastic
     */
    type: PlasticTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Plastic
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Plastic
     */
    rReflectance: number;
    /**
     * 
     * @type {number}
     * @memberof Plastic
     */
    gReflectance: number;
    /**
     * 
     * @type {number}
     * @memberof Plastic
     */
    bReflectance: number;
    /**
     * 
     * @type {number}
     * @memberof Plastic
     */
    specularity: number;
    /**
     * 
     * @type {number}
     * @memberof Plastic
     */
    roughness: number;
    /**
     * 
     * @type {string}
     * @memberof Plastic
     */
    modifier?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PlasticTypeEnum {
    Plastic = 'Plastic'
}

/**
 * Arguments to a task or a workflow.  Queenbee accepts two types of arguments: parameters and artifacts. A ``parameter`` is a variable that can be passed to a task or a workflow. An ``artifact`` is a file or folder that can be identified by a url or a path.
 * @export
 * @interface QueenbeeArgoSchemaArgumentsArguments
 */
export interface QueenbeeArgoSchemaArgumentsArguments {
    /**
     * Parameters is the list of input parameters to pass to the task or workflow. A parameter can have a default value which will be overwritten if an input value is provided.
     * @type {Array<QueenbeeArgoSchemaArgumentsParameter>}
     * @memberof QueenbeeArgoSchemaArgumentsArguments
     */
    parameters?: Array<QueenbeeArgoSchemaArgumentsParameter>;
    /**
     * Artifacts is the list of file and folder arguments to pass to the task or workflow.
     * @type {Array<QueenbeeArgoSchemaArgumentsArtifact>}
     * @memberof QueenbeeArgoSchemaArgumentsArguments
     */
    artifacts?: Array<QueenbeeArgoSchemaArgumentsArtifact>;
}
/**
 * Artifact indicates an artifact to place at a specified path
 * @export
 * @interface QueenbeeArgoSchemaArgumentsArtifact
 */
export interface QueenbeeArgoSchemaArgumentsArtifact {
    /**
     * name of the artifact. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof QueenbeeArgoSchemaArgumentsArtifact
     */
    name: string;
    /**
     * Path the artifact should be copied to in the temporary task folder.
     * @type {string}
     * @memberof QueenbeeArgoSchemaArgumentsArtifact
     */
    path?: string;
    /**
     * 
     * @type {object}
     * @memberof QueenbeeArgoSchemaArgumentsArtifact
     */
    archive?: object;
    /**
     * 
     * @type {S3Location}
     * @memberof QueenbeeArgoSchemaArgumentsArtifact
     */
    s3?: S3Location;
}
/**
 * Parameter.  Parameter indicate a passed string parameter to a service template with an optional default value.
 * @export
 * @interface QueenbeeArgoSchemaArgumentsParameter
 */
export interface QueenbeeArgoSchemaArgumentsParameter {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof QueenbeeArgoSchemaArgumentsParameter
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {object}
     * @memberof QueenbeeArgoSchemaArgumentsParameter
     */
    value?: object;
}
/**
 * Arguments to a task or a workflow.  Queenbee accepts two types of arguments: parameters and artifacts. A ``parameter`` is a variable that can be passed to a task or a workflow. An ``artifact`` is a file or folder that can be identified by a url or a path.
 * @export
 * @interface QueenbeeSchemaArgumentsArguments
 */
export interface QueenbeeSchemaArgumentsArguments {
    /**
     * Parameters is the list of input parameters to pass to the task or workflow. A parameter can have a default value which will be overwritten if an input value is provided.
     * @type {Array<QueenbeeSchemaArgumentsParameter>}
     * @memberof QueenbeeSchemaArgumentsArguments
     */
    parameters?: Array<QueenbeeSchemaArgumentsParameter>;
    /**
     * Artifacts is the list of file and folder arguments to pass to the task or workflow.
     * @type {Array<QueenbeeSchemaArgumentsArtifact>}
     * @memberof QueenbeeSchemaArgumentsArguments
     */
    artifacts?: Array<QueenbeeSchemaArgumentsArtifact>;
}
/**
 * Artifact indicates an artifact to place at a specified path
 * @export
 * @interface QueenbeeSchemaArgumentsArtifact
 */
export interface QueenbeeSchemaArgumentsArtifact {
    /**
     * name of the artifact. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    name: string;
    /**
     * Name of the Artifact Location to source this artifact from.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    location?: string;
    /**
     * Path to the artifact on the local machine, url or S3 bucket.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    sourcePath?: string;
    /**
     * Path the artifact should be copied to in the temporary task folder.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    path?: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    description?: string;
    /**
     * An object with Key Value pairs of HTTP headers. For artifacts from URL Location only
     * @type {{ [key: string]: string; }}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    headers?: { [key: string]: string; };
    /**
     * The HTTP verb to use when making the request. For artifacts from URL Location only
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsArtifact
     */
    verb?: QueenbeeSchemaArgumentsArtifactVerbEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum QueenbeeSchemaArgumentsArtifactVerbEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * Parameter.  Parameter indicate a passed string parameter to a service template with an optional default value.
 * @export
 * @interface QueenbeeSchemaArgumentsParameter
 */
export interface QueenbeeSchemaArgumentsParameter {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsParameter
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {object}
     * @memberof QueenbeeSchemaArgumentsParameter
     */
    value?: object;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsParameter
     */
    description?: string;
    /**
     * load parameters from a file. File can be a JSON / YAML or a text file.
     * @type {string}
     * @memberof QueenbeeSchemaArgumentsParameter
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface ReferenceWorkflow
 */
export interface ReferenceWorkflow {
    /**
     * 
     * @type {string}
     * @memberof ReferenceWorkflow
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceWorkflow
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceWorkflow
     */
    link: string;
}
/**
 * An argo retry strategy
 * @export
 * @interface RetryStrategy
 */
export interface RetryStrategy {
    /**
     * 
     * @type {number}
     * @memberof RetryStrategy
     */
    limit?: number;
}
/**
 * S3Location  An S3 bucket
 * @export
 * @interface S3Location
 */
export interface S3Location {
    /**
     * 
     * @type {string}
     * @memberof S3Location
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof S3Location
     */
    name: string;
    /**
     * The path inside the bucket to source artifacts from.
     * @type {string}
     * @memberof S3Location
     */
    root?: string;
    /**
     * The HTTP endpoint to reach the S3 bucket.
     * @type {string}
     * @memberof S3Location
     */
    endpoint: string;
    /**
     * The name of the S3 bucket on the host server.
     * @type {string}
     * @memberof S3Location
     */
    bucket: string;
    /**
     * Path to the file holding the AccessKey and SecretAccessKey to authenticate to the bucket
     * @type {string}
     * @memberof S3Location
     */
    credentialsPath: string;
}
/**
 * A single sensor.      The first 3 values indicate the location and the second 3 valuse indicate the     direction of the sensor.
 * @export
 * @interface Sensor
 */
export interface Sensor {
    /**
     * X coordinate of sensor location
     * @type {number}
     * @memberof Sensor
     */
    x: number;
    /**
     * Y coordinate of sensor location
     * @type {number}
     * @memberof Sensor
     */
    y: number;
    /**
     * Z coordinate of sensor location
     * @type {number}
     * @memberof Sensor
     */
    z: number;
    /**
     * X coordinate of sensor direction
     * @type {number}
     * @memberof Sensor
     */
    dx: number;
    /**
     * Y coordinate of sensor direction
     * @type {number}
     * @memberof Sensor
     */
    dy: number;
    /**
     * Z coordinate of sensor direction
     * @type {number}
     * @memberof Sensor
     */
    dz: number;
}
/**
 * A flattened collection of sensors for grid-based studies.
 * @export
 * @interface SensorGridIn
 */
export interface SensorGridIn {
    /**
     * 
     * @type {string}
     * @memberof SensorGridIn
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGridIn
     */
    name: string;
    /**
     * A flattened array of sensors.
     * @type {Array<Sensor>}
     * @memberof SensorGridIn
     */
    sensors: Array<Sensor>;
}
/**
 * A flattened collection of sensors for grid-based studies.
 * @export
 * @interface SensorGridIn1
 */
export interface SensorGridIn1 {
    /**
     * 
     * @type {string}
     * @memberof SensorGridIn1
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGridIn1
     */
    name: string;
    /**
     * A flattened array of sensors.
     * @type {Array<Sensor>}
     * @memberof SensorGridIn1
     */
    sensors: Array<Sensor>;
}
/**
 * A flattened collection of sensors for grid-based studies.
 * @export
 * @interface SensorGridOut
 */
export interface SensorGridOut {
    /**
     * 
     * @type {string}
     * @memberof SensorGridOut
     */
    type?: string;
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof SensorGridOut
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGridOut
     */
    name: string;
    /**
     * Total number of sensors.
     * @type {number}
     * @memberof SensorGridOut
     */
    sensorCount: number;
    /**
     * Sensor grid creation time.
     * @type {string}
     * @memberof SensorGridOut
     */
    createdAt?: string;
    /**
     * URL to get sensors for this grid.
     * @type {string}
     * @memberof SensorGridOut
     */
    url: string;
    /**
     * URL to the sensor grid.
     * @type {string}
     * @memberof SensorGridOut
     */
    sensorsUrl: string;
}
/**
 * An argo workflow step sequence object
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    count?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    format?: string;
}
/**
 * ShadeFace Schema
 * @export
 * @interface ShadeFace
 */
export interface ShadeFace {
    /**
     * Unique UUID value.
     * @type {string}
     * @memberof ShadeFace
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ShadeFace
     */
    name: string;
    /**
     * 
     * @type {Array<Vertex>}
     * @memberof ShadeFace
     */
    vertices: Array<Vertex>;
    /**
     * 
     * @type {string}
     * @memberof ShadeFace
     */
    faceType: ShadeFaceFaceTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof ShadeFace
     */
    radModifier?: object;
    /**
     * 
     * @type {object}
     * @memberof ShadeFace
     */
    radModifierDir?: object;
    /**
     * 
     * @type {string}
     * @memberof ShadeFace
     */
    type: ShadeFaceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShadeFaceFaceTypeEnum {
    Shading = 'Shading'
}
/**
    * @export
    * @enum {string}
    */
export enum ShadeFaceTypeEnum {
    ShadeFace = 'ShadeFace'
}

/**
 * An argo workflow status object
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {{ [key: string]: Template; }}
     * @memberof Status
     */
    storedTemplates: { [key: string]: Template; };
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    phase?: string;
    /**
     * 
     * @type {Date}
     * @memberof Status
     */
    startedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Status
     */
    finishedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    compressedNodes?: string;
    /**
     * 
     * @type {{ [key: string]: NodeStatus; }}
     * @memberof Status
     */
    nodes?: { [key: string]: NodeStatus; };
    /**
     * 
     * @type {Array<object>}
     * @memberof Status
     */
    persistentVolumeClaims?: Array<object>;
    /**
     * 
     * @type {Outputs}
     * @memberof Status
     */
    outputs?: Outputs;
}
/**
 * An argo template step
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {Array<WorkflowStep>}
     * @memberof Step
     */
    steps: Array<WorkflowStep>;
}
/**
 * 
 * @export
 * @interface SubmitSimulation
 */
export interface SubmitSimulation {
    /**
     * 
     * @type {string}
     * @memberof SubmitSimulation
     */
    workflow: string;
    /**
     * 
     * @type {QueenbeeSchemaArgumentsArguments}
     * @memberof SubmitSimulation
     */
    inputs?: QueenbeeSchemaArgumentsArguments;
}
/**
 * An argo template suspension object
 * @export
 * @interface Suspend
 */
export interface Suspend {
    /**
     * 
     * @type {number}
     * @memberof Suspend
     */
    duration?: number;
}
/**
 * An argo task container object
 * @export
 * @interface TaskContainer
 */
export interface TaskContainer {
    /**
     * 
     * @type {string}
     * @memberof TaskContainer
     */
    image: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskContainer
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskContainer
     */
    args?: Array<string>;
}
/**
 * An argo workflow template object
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    template?: string;
    /**
     * 
     * @type {QueenbeeArgoSchemaArgumentsArguments}
     * @memberof Template
     */
    arguments?: QueenbeeArgoSchemaArgumentsArguments;
    /**
     * 
     * @type {TemplateRef}
     * @memberof Template
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {QueenbeeArgoSchemaArgumentsArguments}
     * @memberof Template
     */
    inputs?: QueenbeeArgoSchemaArgumentsArguments;
    /**
     * 
     * @type {Outputs}
     * @memberof Template
     */
    outputs?: Outputs;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    daemon?: boolean;
    /**
     * 
     * @type {Array<Step>}
     * @memberof Template
     */
    steps?: Array<Step>;
    /**
     * 
     * @type {TaskContainer}
     * @memberof Template
     */
    container?: TaskContainer;
    /**
     * 
     * @type {DAG}
     * @memberof Template
     */
    dag?: DAG;
    /**
     * 
     * @type {Suspend}
     * @memberof Template
     */
    suspend?: Suspend;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    activeDeadlineSeconds?: number;
    /**
     * 
     * @type {RetryStrategy}
     * @memberof Template
     */
    retryStrategy?: RetryStrategy;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    parallelism?: number;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    serviceAccountName?: string;
}
/**
 * An argo template reference object
 * @export
 * @interface TemplateRef
 */
export interface TemplateRef {
    /**
     * 
     * @type {string}
     * @memberof TemplateRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRef
     */
    template?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRef
     */
    runtimeResolution?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    secret?: string;
}
/**
 * Transparent Material Schema
 * @export
 * @interface Transparent
 */
export interface Transparent {
    /**
     * 
     * @type {string}
     * @memberof Transparent
     */
    type: TransparentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transparent
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Transparent
     */
    transmittance: number;
}

/**
    * @export
    * @enum {string}
    */
export enum TransparentTypeEnum {
    Transparent = 'Transparent'
}

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * Individual Vertex Schema
 * @export
 * @interface Vertex
 */
export interface Vertex {
    /**
     * X coordinate of the vertex
     * @type {number}
     * @memberof Vertex
     */
    x: number;
    /**
     * y coordinate of the vertex
     * @type {number}
     * @memberof Vertex
     */
    y: number;
    /**
     * z coordinate of the vertex
     * @type {number}
     * @memberof Vertex
     */
    z: number;
}
/**
 * A DAG Workflow.
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    name: string;
    /**
     * 
     * @type {Array<Operator>}
     * @memberof Workflow
     */
    operators: Array<Operator>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Workflow
     */
    templates: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
    /**
     * 
     * @type {Arguments}
     * @memberof Workflow
     */
    inputs?: Arguments;
    /**
     * A list of steps for using tasks in a DAG workflow
     * @type {DAG}
     * @memberof Workflow
     */
    flow: DAG;
    /**
     * 
     * @type {Arguments}
     * @memberof Workflow
     */
    outputs?: Arguments;
    /**
     * A list of artifact locations which can be used by child flow objects
     * @type {Array<object>}
     * @memberof Workflow
     */
    artifactLocations?: Array<object>;
}
/**
 * 
 * @export
 * @interface WorkflowListItem
 */
export interface WorkflowListItem {
    /**
     * 
     * @type {string}
     * @memberof WorkflowListItem
     */
    id: string;
    /**
     * 
     * @type {ReferenceWorkflow}
     * @memberof WorkflowListItem
     */
    workflowRef: ReferenceWorkflow;
    /**
     * 
     * @type {QueenbeeSchemaArgumentsArguments}
     * @memberof WorkflowListItem
     */
    inputs: QueenbeeSchemaArgumentsArguments;
    /**
     * 
     * @type {string}
     * @memberof WorkflowListItem
     */
    phase: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowListItem
     */
    completed: boolean;
    /**
     * 
     * @type {Date}
     * @memberof WorkflowListItem
     */
    startedAt: Date;
    /**
     * 
     * @type {string}
     * @memberof WorkflowListItem
     */
    selfLink: string;
    /**
     * 
     * @type {Status}
     * @memberof WorkflowListItem
     */
    status?: Status;
    /**
     * 
     * @type {Date}
     * @memberof WorkflowListItem
     */
    finishedAt?: Date;
}
/**
 * An argo template workflow step
 * @export
 * @interface WorkflowStep
 */
export interface WorkflowStep {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    template?: string;
    /**
     * 
     * @type {QueenbeeArgoSchemaArgumentsArguments}
     * @memberof WorkflowStep
     */
    arguments?: QueenbeeArgoSchemaArgumentsArguments;
    /**
     * 
     * @type {TemplateRef}
     * @memberof WorkflowStep
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {Array<object>}
     * @memberof WorkflowStep
     */
    withItems?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    withParam?: string;
    /**
     * 
     * @type {Sequence}
     * @memberof WorkflowStep
     */
    withSequence?: Sequence;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    when?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    continueOn?: string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 * @hidden
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new api token.
         * @summary Create an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken(options: any = {}): RequestArgs {
            const localVarPath = `/auth/api-token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API Token.
         * @summary Delete an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken(options: any = {}): RequestArgs {
            const localVarPath = `/auth/api-token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API Token Name.
         * @summary Get your API Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiToken(options: any = {}): RequestArgs {
            const localVarPath = `/auth/api-token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login user with token data
         * @summary Login with API Token
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(token: Token, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling login.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof token !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(token !== undefined ? token : {}) : (token || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotate a token\'s secret.
         * @summary Rotate an API token secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiTokenSecret(options: any = {}): RequestArgs {
            const localVarPath = `/auth/api-token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 * @hidden
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new api token.
         * @summary Create an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).createApiToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an API Token.
         * @summary Delete an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).deleteApiToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve an API Token Name.
         * @summary Get your API Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiToken(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewToken> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).getApiToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Login user with token data
         * @summary Login with API Token
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(token: Token, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth0TokenResponse> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).login(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rotate a token\'s secret.
         * @summary Rotate an API token secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiTokenSecret(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).rotateApiTokenSecret(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 * @hidden
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new api token.
         * @summary Create an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken(options?: any) {
            return AuthenticationApiFp(configuration).createApiToken(options)(axios, basePath);
        },
        /**
         * Delete an API Token.
         * @summary Delete an API Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken(options?: any) {
            return AuthenticationApiFp(configuration).deleteApiToken(options)(axios, basePath);
        },
        /**
         * Retrieve an API Token Name.
         * @summary Get your API Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiToken(options?: any) {
            return AuthenticationApiFp(configuration).getApiToken(options)(axios, basePath);
        },
        /**
         * Login user with token data
         * @summary Login with API Token
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(token: Token, options?: any) {
            return AuthenticationApiFp(configuration).login(token, options)(axios, basePath);
        },
        /**
         * Rotate a token\'s secret.
         * @summary Rotate an API token secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiTokenSecret(options?: any) {
            return AuthenticationApiFp(configuration).rotateApiTokenSecret(options)(axios, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Create a new api token.
     * @summary Create an API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    createApiToken(options?: any): AxiosPromise<Token>;

    /**
     * Delete an API Token.
     * @summary Delete an API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    deleteApiToken(options?: any): AxiosPromise<object>;

    /**
     * Retrieve an API Token Name.
     * @summary Get your API Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getApiToken(options?: any): AxiosPromise<NewToken>;

    /**
     * Login user with token data
     * @summary Login with API Token
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    login(token: Token, options?: any): AxiosPromise<Auth0TokenResponse>;

    /**
     * Rotate a token\'s secret.
     * @summary Rotate an API token secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    rotateApiTokenSecret(options?: any): AxiosPromise<Token>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Create a new api token.
     * @summary Create an API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createApiToken(options?: any) {
        return AuthenticationApiFp(this.configuration).createApiToken(options)(this.axios, this.basePath);
    }

    /**
     * Delete an API Token.
     * @summary Delete an API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteApiToken(options?: any) {
        return AuthenticationApiFp(this.configuration).deleteApiToken(options)(this.axios, this.basePath);
    }

    /**
     * Retrieve an API Token Name.
     * @summary Get your API Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getApiToken(options?: any) {
        return AuthenticationApiFp(this.configuration).getApiToken(options)(this.axios, this.basePath);
    }

    /**
     * Login user with token data
     * @summary Login with API Token
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(token: Token, options?: any) {
        return AuthenticationApiFp(this.configuration).login(token, options)(this.axios, this.basePath);
    }

    /**
     * Rotate a token\'s secret.
     * @summary Rotate an API token secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public rotateApiTokenSecret(options?: any) {
        return AuthenticationApiFp(this.configuration).rotateApiTokenSecret(options)(this.axios, this.basePath);
    }

}


/**
 * ModelApi - axios parameter creator
 * @export
 * @hidden
 */
export const ModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Model
         * @param {string} id Model id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new model.
         * @summary Create a Model
         * @param {Model1} model1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model1: Model1, options: any = {}): RequestArgs {
            // verify required parameter 'model1' is not null or undefined
            if (model1 === null || model1 === undefined) {
                throw new RequiredError('model1','Required parameter model1 was null or undefined when calling create.');
            }
            const localVarPath = `/models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof model1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(model1 !== undefined ? model1 : {}) : (model1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new model faces.
         * @summary Create Model Faces
         * @param {string} id 
         * @param {Array<Face>} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaces(id: string, face: Array<Face>, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createFaces.');
            }
            // verify required parameter 'face' is not null or undefined
            if (face === null || face === undefined) {
                throw new RequiredError('face','Required parameter face was null or undefined when calling createFaces.');
            }
            const localVarPath = `/models/{id}/faces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof face !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(face !== undefined ? face : {}) : (face || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Model
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Model Faces
         * @param {string} id 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaces(id: string, page?: number, perPage?: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFaces.');
            }
            const localVarPath = `/models/{id}/faces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of models.
         * @summary Get Models
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options: any = {}): RequestArgs {
            const localVarPath = `/models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelApi - functional programming interface
 * @export
 * @hidden
 */
export const ModelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Model
         * @param {string} id Model id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration)._delete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new model.
         * @summary Create a Model
         * @param {Model1} model1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model1: Model1, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration).create(model1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new model faces.
         * @summary Create Model Faces
         * @param {string} id 
         * @param {Array<Face>} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaces(id: string, face: Array<Face>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration).createFaces(id, face, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Model
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOut> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Model Faces
         * @param {string} id 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaces(id: string, page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Face>> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration).getFaces(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of models.
         * @summary Get Models
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelOut>> {
            const localVarAxiosArgs = ModelApiAxiosParamCreator(configuration).list(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ModelApi - factory interface
 * @export
 * @hidden
 */
export const ModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Model
         * @param {string} id Model id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any) {
            return ModelApiFp(configuration)._delete(id, options)(axios, basePath);
        },
        /**
         * Create a new model.
         * @summary Create a Model
         * @param {Model1} model1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model1: Model1, options?: any) {
            return ModelApiFp(configuration).create(model1, options)(axios, basePath);
        },
        /**
         * Create new model faces.
         * @summary Create Model Faces
         * @param {string} id 
         * @param {Array<Face>} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaces(id: string, face: Array<Face>, options?: any) {
            return ModelApiFp(configuration).createFaces(id, face, options)(axios, basePath);
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Model
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any) {
            return ModelApiFp(configuration).get(id, options)(axios, basePath);
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Model Faces
         * @param {string} id 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaces(id: string, page?: number, perPage?: number, options?: any) {
            return ModelApiFp(configuration).getFaces(id, page, perPage, options)(axios, basePath);
        },
        /**
         * Retrieve a list of models.
         * @summary Get Models
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any) {
            return ModelApiFp(configuration).list(page, perPage, options)(axios, basePath);
        },
    };
};

/**
 * ModelApi - interface
 * @export
 * @interface ModelApi
 */
export interface ModelApiInterface {
    /**
     * Delete a sensor grid.
     * @summary Delete a Model
     * @param {string} id Model id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    _delete(id: string, options?: any): AxiosPromise<object>;

    /**
     * Create a new model.
     * @summary Create a Model
     * @param {Model1} model1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    create(model1: Model1, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Create new model faces.
     * @summary Create Model Faces
     * @param {string} id 
     * @param {Array<Face>} face 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    createFaces(id: string, face: Array<Face>, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Retrieve a sensor grid.
     * @summary Get a Model
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    get(id: string, options?: any): AxiosPromise<ModelOut>;

    /**
     * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
     * @summary Get Model Faces
     * @param {string} id 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    getFaces(id: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Face>>;

    /**
     * Retrieve a list of models.
     * @summary Get Models
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApiInterface
     */
    list(page?: number, perPage?: number, options?: any): AxiosPromise<Array<ModelOut>>;

}

/**
 * ModelApi - object-oriented interface
 * @export
 * @class ModelApi
 * @extends {BaseAPI}
 */
export class ModelApi extends BaseAPI implements ModelApiInterface {
    /**
     * Delete a sensor grid.
     * @summary Delete a Model
     * @param {string} id Model id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public _delete(id: string, options?: any) {
        return ModelApiFp(this.configuration)._delete(id, options)(this.axios, this.basePath);
    }

    /**
     * Create a new model.
     * @summary Create a Model
     * @param {Model1} model1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public create(model1: Model1, options?: any) {
        return ModelApiFp(this.configuration).create(model1, options)(this.axios, this.basePath);
    }

    /**
     * Create new model faces.
     * @summary Create Model Faces
     * @param {string} id 
     * @param {Array<Face>} face 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public createFaces(id: string, face: Array<Face>, options?: any) {
        return ModelApiFp(this.configuration).createFaces(id, face, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a sensor grid.
     * @summary Get a Model
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public get(id: string, options?: any) {
        return ModelApiFp(this.configuration).get(id, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
     * @summary Get Model Faces
     * @param {string} id 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public getFaces(id: string, page?: number, perPage?: number, options?: any) {
        return ModelApiFp(this.configuration).getFaces(id, page, perPage, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of models.
     * @summary Get Models
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public list(page?: number, perPage?: number, options?: any) {
        return ModelApiFp(this.configuration).list(page, perPage, options)(this.axios, this.basePath);
    }

}


/**
 * SensorGridApi - axios parameter creator
 * @export
 * @hidden
 */
export const SensorGridApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Sensor Grid
         * @param {string} gid Grid id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(gid: string, options: any = {}): RequestArgs {
            // verify required parameter 'gid' is not null or undefined
            if (gid === null || gid === undefined) {
                throw new RequiredError('gid','Required parameter gid was null or undefined when calling _delete.');
            }
            const localVarPath = `/sensor-grids/{gid}`
                .replace(`{${"gid"}}`, encodeURIComponent(String(gid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new grid of sensors.
         * @summary Create a Sensor Grid
         * @param {SensorGridIn1} sensorGridIn1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(sensorGridIn1: SensorGridIn1, options: any = {}): RequestArgs {
            // verify required parameter 'sensorGridIn1' is not null or undefined
            if (sensorGridIn1 === null || sensorGridIn1 === undefined) {
                throw new RequiredError('sensorGridIn1','Required parameter sensorGridIn1 was null or undefined when calling create.');
            }
            const localVarPath = `/sensor-grids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof sensorGridIn1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sensorGridIn1 !== undefined ? sensorGridIn1 : {}) : (sensorGridIn1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Sensor Grid
         * @param {string} gid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(gid: string, options: any = {}): RequestArgs {
            // verify required parameter 'gid' is not null or undefined
            if (gid === null || gid === undefined) {
                throw new RequiredError('gid','Required parameter gid was null or undefined when calling get.');
            }
            const localVarPath = `/sensor-grids/{gid}`
                .replace(`{${"gid"}}`, encodeURIComponent(String(gid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Sensors
         * @param {string} gid 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSensors(gid: string, page?: number, perPage?: number, options: any = {}): RequestArgs {
            // verify required parameter 'gid' is not null or undefined
            if (gid === null || gid === undefined) {
                throw new RequiredError('gid','Required parameter gid was null or undefined when calling getSensors.');
            }
            const localVarPath = `/sensor-grids/{gid}/sensors`
                .replace(`{${"gid"}}`, encodeURIComponent(String(gid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of sensor grids.
         * @summary Get Sensor Grids
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options: any = {}): RequestArgs {
            const localVarPath = `/sensor-grids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SensorGridApi - functional programming interface
 * @export
 * @hidden
 */
export const SensorGridApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Sensor Grid
         * @param {string} gid Grid id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(gid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SensorGridApiAxiosParamCreator(configuration)._delete(gid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new grid of sensors.
         * @summary Create a Sensor Grid
         * @param {SensorGridIn1} sensorGridIn1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(sensorGridIn1: SensorGridIn1, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SensorGridApiAxiosParamCreator(configuration).create(sensorGridIn1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Sensor Grid
         * @param {string} gid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(gid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SensorGridOut> {
            const localVarAxiosArgs = SensorGridApiAxiosParamCreator(configuration).get(gid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Sensors
         * @param {string} gid 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSensors(gid: string, page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sensor>> {
            const localVarAxiosArgs = SensorGridApiAxiosParamCreator(configuration).getSensors(gid, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of sensor grids.
         * @summary Get Sensor Grids
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorGridOut>> {
            const localVarAxiosArgs = SensorGridApiAxiosParamCreator(configuration).list(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SensorGridApi - factory interface
 * @export
 * @hidden
 */
export const SensorGridApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a sensor grid.
         * @summary Delete a Sensor Grid
         * @param {string} gid Grid id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(gid: string, options?: any) {
            return SensorGridApiFp(configuration)._delete(gid, options)(axios, basePath);
        },
        /**
         * Create a new grid of sensors.
         * @summary Create a Sensor Grid
         * @param {SensorGridIn1} sensorGridIn1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(sensorGridIn1: SensorGridIn1, options?: any) {
            return SensorGridApiFp(configuration).create(sensorGridIn1, options)(axios, basePath);
        },
        /**
         * Retrieve a sensor grid.
         * @summary Get a Sensor Grid
         * @param {string} gid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(gid: string, options?: any) {
            return SensorGridApiFp(configuration).get(gid, options)(axios, basePath);
        },
        /**
         * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
         * @summary Get Sensors
         * @param {string} gid 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSensors(gid: string, page?: number, perPage?: number, options?: any) {
            return SensorGridApiFp(configuration).getSensors(gid, page, perPage, options)(axios, basePath);
        },
        /**
         * Retrieve a list of sensor grids.
         * @summary Get Sensor Grids
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any) {
            return SensorGridApiFp(configuration).list(page, perPage, options)(axios, basePath);
        },
    };
};

/**
 * SensorGridApi - interface
 * @export
 * @interface SensorGridApi
 */
export interface SensorGridApiInterface {
    /**
     * Delete a sensor grid.
     * @summary Delete a Sensor Grid
     * @param {string} gid Grid id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApiInterface
     */
    _delete(gid: string, options?: any): AxiosPromise<object>;

    /**
     * Create a new grid of sensors.
     * @summary Create a Sensor Grid
     * @param {SensorGridIn1} sensorGridIn1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApiInterface
     */
    create(sensorGridIn1: SensorGridIn1, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Retrieve a sensor grid.
     * @summary Get a Sensor Grid
     * @param {string} gid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApiInterface
     */
    get(gid: string, options?: any): AxiosPromise<SensorGridOut>;

    /**
     * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
     * @summary Get Sensors
     * @param {string} gid 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApiInterface
     */
    getSensors(gid: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Sensor>>;

    /**
     * Retrieve a list of sensor grids.
     * @summary Get Sensor Grids
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApiInterface
     */
    list(page?: number, perPage?: number, options?: any): AxiosPromise<Array<SensorGridOut>>;

}

/**
 * SensorGridApi - object-oriented interface
 * @export
 * @class SensorGridApi
 * @extends {BaseAPI}
 */
export class SensorGridApi extends BaseAPI implements SensorGridApiInterface {
    /**
     * Delete a sensor grid.
     * @summary Delete a Sensor Grid
     * @param {string} gid Grid id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApi
     */
    public _delete(gid: string, options?: any) {
        return SensorGridApiFp(this.configuration)._delete(gid, options)(this.axios, this.basePath);
    }

    /**
     * Create a new grid of sensors.
     * @summary Create a Sensor Grid
     * @param {SensorGridIn1} sensorGridIn1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApi
     */
    public create(sensorGridIn1: SensorGridIn1, options?: any) {
        return SensorGridApiFp(this.configuration).create(sensorGridIn1, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a sensor grid.
     * @summary Get a Sensor Grid
     * @param {string} gid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApi
     */
    public get(gid: string, options?: any) {
        return SensorGridApiFp(this.configuration).get(gid, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve list of sensors for a sensor grid.     See Location in response headers for paging links.     
     * @summary Get Sensors
     * @param {string} gid 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApi
     */
    public getSensors(gid: string, page?: number, perPage?: number, options?: any) {
        return SensorGridApiFp(this.configuration).getSensors(gid, page, perPage, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of sensor grids.
     * @summary Get Sensor Grids
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SensorGridApi
     */
    public list(page?: number, perPage?: number, options?: any) {
        return SensorGridApiFp(this.configuration).list(page, perPage, options)(this.axios, this.basePath);
    }

}


/**
 * SimulationsApi - axios parameter creator
 * @export
 * @hidden
 */
export const SimulationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workflow.
         * @summary Schedule a simulation
         * @param {SubmitSimulation} submitSimulation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(submitSimulation: SubmitSimulation, options: any = {}): RequestArgs {
            // verify required parameter 'submitSimulation' is not null or undefined
            if (submitSimulation === null || submitSimulation === undefined) {
                throw new RequiredError('submitSimulation','Required parameter submitSimulation was null or undefined when calling create.');
            }
            const localVarPath = `/simulations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof submitSimulation !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(submitSimulation !== undefined ? submitSimulation : {}) : (submitSimulation || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/simulations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options: any = {}): RequestArgs {
            const localVarPath = `/simulations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmit(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resubmit.');
            }
            const localVarPath = `/simulations/{id}/re-submit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resume.');
            }
            const localVarPath = `/simulations/{id}/resume`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspend(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling suspend.');
            }
            const localVarPath = `/simulations/{id}/suspend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationsApi - functional programming interface
 * @export
 * @hidden
 */
export const SimulationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new workflow.
         * @summary Schedule a simulation
         * @param {SubmitSimulation} submitSimulation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(submitSimulation: SubmitSimulation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).create(submitSimulation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowListItem> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowListItem>> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).list(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmit(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).resubmit(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).resume(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspend(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).suspend(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SimulationsApi - factory interface
 * @export
 * @hidden
 */
export const SimulationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new workflow.
         * @summary Schedule a simulation
         * @param {SubmitSimulation} submitSimulation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(submitSimulation: SubmitSimulation, options?: any) {
            return SimulationsApiFp(configuration).create(submitSimulation, options)(axios, basePath);
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any) {
            return SimulationsApiFp(configuration).get(id, options)(axios, basePath);
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any) {
            return SimulationsApiFp(configuration).list(page, perPage, options)(axios, basePath);
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmit(id: string, options?: any) {
            return SimulationsApiFp(configuration).resubmit(id, options)(axios, basePath);
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(id: string, options?: any) {
            return SimulationsApiFp(configuration).resume(id, options)(axios, basePath);
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspend(id: string, options?: any) {
            return SimulationsApiFp(configuration).suspend(id, options)(axios, basePath);
        },
    };
};

/**
 * SimulationsApi - interface
 * @export
 * @interface SimulationsApi
 */
export interface SimulationsApiInterface {
    /**
     * Create a new workflow.
     * @summary Schedule a simulation
     * @param {SubmitSimulation} submitSimulation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    create(submitSimulation: SubmitSimulation, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Retrieve a workflow.
     * @summary Get a Simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    get(id: string, options?: any): AxiosPromise<WorkflowListItem>;

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    list(page?: number, perPage?: number, options?: any): AxiosPromise<Array<WorkflowListItem>>;

    /**
     * re-submit a simulation
     * @summary re-submit a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    resubmit(id: string, options?: any): AxiosPromise<CreatedContent>;

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    resume(id: string, options?: any): AxiosPromise<Accepted>;

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    suspend(id: string, options?: any): AxiosPromise<Accepted>;

}

/**
 * SimulationsApi - object-oriented interface
 * @export
 * @class SimulationsApi
 * @extends {BaseAPI}
 */
export class SimulationsApi extends BaseAPI implements SimulationsApiInterface {
    /**
     * Create a new workflow.
     * @summary Schedule a simulation
     * @param {SubmitSimulation} submitSimulation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public create(submitSimulation: SubmitSimulation, options?: any) {
        return SimulationsApiFp(this.configuration).create(submitSimulation, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a workflow.
     * @summary Get a Simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public get(id: string, options?: any) {
        return SimulationsApiFp(this.configuration).get(id, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public list(page?: number, perPage?: number, options?: any) {
        return SimulationsApiFp(this.configuration).list(page, perPage, options)(this.axios, this.basePath);
    }

    /**
     * re-submit a simulation
     * @summary re-submit a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public resubmit(id: string, options?: any) {
        return SimulationsApiFp(this.configuration).resubmit(id, options)(this.axios, this.basePath);
    }

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public resume(id: string, options?: any) {
        return SimulationsApiFp(this.configuration).resume(id, options)(this.axios, this.basePath);
    }

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public suspend(id: string, options?: any) {
        return SimulationsApiFp(this.configuration).suspend(id, options)(this.axios, this.basePath);
    }

}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 * @hidden
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a workflow.
         * @summary Delete a Workflow
         * @param {string} id Simulation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling create.');
            }
            const localVarPath = `/workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof workflow !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow !== undefined ? workflow : {}) : (workflow || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of workflows.
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options: any = {}): RequestArgs {
            const localVarPath = `/workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a workflow.
         * @summary Update a Workflow
         * @param {string} id 
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
            }
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling update.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof workflow !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow !== undefined ? workflow : {}) : (workflow || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 * @hidden
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a workflow.
         * @summary Delete a Workflow
         * @param {string} id Simulation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration)._delete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).create(workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of workflows.
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).list(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a workflow.
         * @summary Update a Workflow
         * @param {string} id 
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).update(id, workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 * @hidden
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a workflow.
         * @summary Delete a Workflow
         * @param {string} id Simulation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any) {
            return WorkflowsApiFp(configuration)._delete(id, options)(axios, basePath);
        },
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(workflow: Workflow, options?: any) {
            return WorkflowsApiFp(configuration).create(workflow, options)(axios, basePath);
        },
        /**
         * Retrieve a workflow.
         * @summary Get a Workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any) {
            return WorkflowsApiFp(configuration).get(id, options)(axios, basePath);
        },
        /**
         * Retrieve a list of workflows.
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(page?: number, perPage?: number, options?: any) {
            return WorkflowsApiFp(configuration).list(page, perPage, options)(axios, basePath);
        },
        /**
         * Update a workflow.
         * @summary Update a Workflow
         * @param {string} id 
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, workflow: Workflow, options?: any) {
            return WorkflowsApiFp(configuration).update(id, workflow, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowsApi - interface
 * @export
 * @interface WorkflowsApi
 */
export interface WorkflowsApiInterface {
    /**
     * Delete a workflow.
     * @summary Delete a Workflow
     * @param {string} id Simulation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    _delete(id: string, options?: any): AxiosPromise<object>;

    /**
     * Create a new workflow.
     * @summary Create a Workflow
     * @param {Workflow} workflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    create(workflow: Workflow, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a workflow.
     * @summary Get a Workflow
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    get(id: string, options?: any): AxiosPromise<Workflow>;

    /**
     * Retrieve a list of workflows.
     * @summary List Workflows
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    list(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Workflow>>;

    /**
     * Update a workflow.
     * @summary Update a Workflow
     * @param {string} id 
     * @param {Workflow} workflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    update(id: string, workflow: Workflow, options?: any): AxiosPromise<Workflow>;

}

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI implements WorkflowsApiInterface {
    /**
     * Delete a workflow.
     * @summary Delete a Workflow
     * @param {string} id Simulation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public _delete(id: string, options?: any) {
        return WorkflowsApiFp(this.configuration)._delete(id, options)(this.axios, this.basePath);
    }

    /**
     * Create a new workflow.
     * @summary Create a Workflow
     * @param {Workflow} workflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public create(workflow: Workflow, options?: any) {
        return WorkflowsApiFp(this.configuration).create(workflow, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a workflow.
     * @summary Get a Workflow
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public get(id: string, options?: any) {
        return WorkflowsApiFp(this.configuration).get(id, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of workflows.
     * @summary List Workflows
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public list(page?: number, perPage?: number, options?: any) {
        return WorkflowsApiFp(this.configuration).list(page, perPage, options)(this.axios, this.basePath);
    }

    /**
     * Update a workflow.
     * @summary Update a Workflow
     * @param {string} id 
     * @param {Workflow} workflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public update(id: string, workflow: Workflow, options?: any) {
        return WorkflowsApiFp(this.configuration).update(id, workflow, options)(this.axios, this.basePath);
    }

}


