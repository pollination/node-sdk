// tslint:disable
/**
 * Pollination Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.3.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Accepted request response.
 * @export
 * @interface Accepted
 */
export interface Accepted {
    /**
     * Url to access the requested resource.
     * @type {string}
     * @memberof Accepted
     */
    url: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof Accepted
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface AccountPublic
 */
export interface AccountPublic {
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublic
     */
    name: string;
}
/**
 * Arguments to a task or a workflow.  Queenbee accepts two types of arguments: parameters and artifacts. A ``parameter`` is a variable that can be passed to a task or a workflow. An ``artifact`` is a file or folder that can be identified by a url or a path.
 * @export
 * @interface Arguments
 */
export interface Arguments {
    /**
     * Parameters is the list of input parameters to pass to the task or workflow. A parameter can have a default value which will be overwritten if an input value is provided.
     * @type {Array<Parameter>}
     * @memberof Arguments
     */
    parameters?: Array<Parameter>;
    /**
     * Artifacts is the list of file and folder arguments to pass to the task or workflow.
     * @type {Array<Artifact>}
     * @memberof Arguments
     */
    artifacts?: Array<Artifact>;
}
/**
 * Artifact indicates an artifact to be placed at a specified path.
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * Name of the artifact. Must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof Artifact
     */
    name: string;
    /**
     * Name of the artifact_location to source this artifact from.
     * @type {string}
     * @memberof Artifact
     */
    location?: string;
    /**
     * Path to the artifact in a url or S3 bucket.
     * @type {string}
     * @memberof Artifact
     */
    sourcePath?: string;
    /**
     * Path to the artifact relative to the run-folder artifact location.
     * @type {string}
     * @memberof Artifact
     */
    path?: string;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof Artifact
     */
    description?: string;
    /**
     * An object with Key Value pairs of HTTP headers. For artifacts from URL location only.
     * @type {{ [key: string]: string; }}
     * @memberof Artifact
     */
    headers?: { [key: string]: string; };
    /**
     * The HTTP verb to use when making the request. For artifacts from URL location only.
     * @type {string}
     * @memberof Artifact
     */
    verb?: ArtifactVerbEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVerbEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * 
 * @export
 * @interface CreateOrgDto
 */
export interface CreateOrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof CreateOrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof CreateOrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof CreateOrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof CreateOrgDto
     */
    description?: string;
    /**
     * The unique name of the org in small case without spaces
     * @type {string}
     * @memberof CreateOrgDto
     */
    accountName: string;
}
/**
 * 
 * @export
 * @interface CreateTokenDto
 */
export interface CreateTokenDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    tokenName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    password: string;
}
/**
 * A DAG Workflow.
 * @export
 * @interface CreateWorkflowDto
 */
export interface CreateWorkflowDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowDto
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowDto
     */
    id?: string;
    /**
     * 
     * @type {Arguments}
     * @memberof CreateWorkflowDto
     */
    inputs?: Arguments;
    /**
     * 
     * @type {Array<Operator>}
     * @memberof CreateWorkflowDto
     */
    operators: Array<Operator>;
    /**
     * A list of templates. Templates can be Function, DAG or a Workflow.
     * @type {Array<object>}
     * @memberof CreateWorkflowDto
     */
    templates: Array<object>;
    /**
     * A list of tasks to create a DAG workflow.
     * @type {DAG}
     * @memberof CreateWorkflowDto
     */
    flow: DAG;
    /**
     * 
     * @type {Arguments}
     * @memberof CreateWorkflowDto
     */
    outputs?: Arguments;
    /**
     * A list of artifact locations which can be used by flow objects.
     * @type {Array<object>}
     * @memberof CreateWorkflowDto
     */
    artifactLocations?: Array<object>;
    /**
     * A boolean indicator of whether workflow is public or not
     * @type {boolean}
     * @memberof CreateWorkflowDto
     */
    _public: boolean;
}
/**
 * Content for created response.
 * @export
 * @interface CreatedContent
 */
export interface CreatedContent {
    /**
     * Id for the newly created resource.
     * @type {string}
     * @memberof CreatedContent
     */
    id: string;
    /**
     *  A human readable message
     * @type {string}
     * @memberof CreatedContent
     */
    message?: string;
}
/**
 * DAG includes different steps of a directed acyclic graph.
 * @export
 * @interface DAG
 */
export interface DAG {
    /**
     * A unique name for this dag.
     * @type {string}
     * @memberof DAG
     */
    name: string;
    /**
     * Target are one or more names of target tasks to execute in a DAG. Multiple targets can be specified as space delimited inputs. When a target is provided only a subset of tasks in DAG that are required to generate the target(s) will be executed.
     * @type {string}
     * @memberof DAG
     */
    target?: string;
    /**
     * Stop scheduling new steps, as soon as it detects that one of the DAG nodes is failed. Default is True.
     * @type {boolean}
     * @memberof DAG
     */
    failFast?: boolean;
    /**
     * Tasks are a list of DAG steps
     * @type {Array<DAGTask>}
     * @memberof DAG
     */
    tasks: Array<DAGTask>;
}
/**
 * DAGTask defines a single step in a Directed Acyclic Graph (DAG) workflow.
 * @export
 * @interface DAGTask
 */
export interface DAGTask {
    /**
     * Name for this step. It must be unique in DAG.
     * @type {string}
     * @memberof DAGTask
     */
    name: string;
    /**
     * Input arguments for template.
     * @type {Arguments}
     * @memberof DAGTask
     */
    arguments?: Arguments;
    /**
     * Template name.
     * @type {string}
     * @memberof DAGTask
     */
    template: string;
    /**
     * Dependencies are name of other DAG steps which this depends on.
     * @type {Array<string>}
     * @memberof DAGTask
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof DAGTask
     */
    loop?: object;
}
/**
 * 
 * @export
 * @interface EmailRequest
 */
export interface EmailRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface FileMeta
 */
export interface FileMeta {
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    fileName: string;
    /**
     * 
     * @type {Date}
     * @memberof FileMeta
     */
    lastModified?: Date;
    /**
     * 
     * @type {number}
     * @memberof FileMeta
     */
    size?: number;
}
/**
 * A function with a single command.
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    type: string;
    /**
     * Function name. Must be unique within a workflow.
     * @type {string}
     * @memberof Function
     */
    name: string;
    /**
     * Function description. A short human readable description for this function.
     * @type {string}
     * @memberof Function
     */
    description?: string;
    /**
     * Input arguments for this function.
     * @type {Arguments}
     * @memberof Function
     */
    inputs?: Arguments;
    /**
     * Full shell command for this function. Each function accepts only one command. The command will be executed as a shell command in operator. For running several commands after each other use && between the commands or pipe data from one to another using |
     * @type {string}
     * @memberof Function
     */
    command: string;
    /**
     * Function operator name.
     * @type {string}
     * @memberof Function
     */
    operator: string;
    /**
     * A dictionary of key:values for environmental variables.
     * @type {{ [key: string]: string; }}
     * @memberof Function
     */
    env?: { [key: string]: string; };
    /**
     * List of output arguments.
     * @type {Arguments}
     * @memberof Function
     */
    outputs?: Arguments;
}
/**
 * HTTPLocation  A web HTTP to an FTP server or an API for example.
 * @export
 * @interface HTTPLocation
 */
export interface HTTPLocation {
    /**
     * 
     * @type {string}
     * @memberof HTTPLocation
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof HTTPLocation
     */
    name: string;
    /**
     * For a HTTP endpoint this can be http://climate.onebuilding.org.
     * @type {string}
     * @memberof HTTPLocation
     */
    root: string;
    /**
     * An object with Key Value pairs of HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof HTTPLocation
     */
    headers?: { [key: string]: string; };
    /**
     * The HTTP verb to use when making the request.
     * @type {string}
     * @memberof HTTPLocation
     */
    verb?: HTTPLocationVerbEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HTTPLocationVerbEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Input Folder Location  This is a folder that the workflow can use to pull input artifacts from. When running locally it can be any folder path on the machine\'s filesystem. When running on the Pollination platform the root.
 * @export
 * @interface InputFolderLocation
 */
export interface InputFolderLocation {
    /**
     * 
     * @type {string}
     * @memberof InputFolderLocation
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof InputFolderLocation
     */
    name: string;
    /**
     * For a local filesystem this can be \"C:\\Users\\me\\simulations\\test\".            Will be ignored when running on the Pollination platform.
     * @type {string}
     * @memberof InputFolderLocation
     */
    root?: string;
}
/**
 * 
 * @export
 * @interface KeyRequest
 */
export interface KeyRequest {
    /**
     * 
     * @type {string}
     * @memberof KeyRequest
     */
    key: string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * An api token generated by calling the POST /user/tokens endpoint
     * @type {string}
     * @memberof LoginDto
     */
    apiToken: string;
}
/**
 * 
 * @export
 * @interface LoginToken
 */
export interface LoginToken {
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    idToken?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginToken
     */
    tokenType: string;
    /**
     * 
     * @type {number}
     * @memberof LoginToken
     */
    expiresIn: number;
}
/**
 * Task operator.  A task operator includes the information for executing tasks from command line or in a container.
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    type?: string;
    /**
     * Operator name. This name should be unique among all the operators in your workflow.
     * @type {string}
     * @memberof Operator
     */
    name: string;
    /**
     * Optional version input for operator.
     * @type {string}
     * @memberof Operator
     */
    version?: string;
    /**
     * Docker image name.
     * @type {string}
     * @memberof Operator
     */
    image: string;
}
/**
 * 
 * @export
 * @interface OrgDto
 */
export interface OrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof OrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof OrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof OrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof OrgDto
     */
    description?: string;
    /**
     * The unique name of the org in small case without spaces
     * @type {string}
     * @memberof OrgDto
     */
    accountName: string;
    /**
     * The org ID
     * @type {string}
     * @memberof OrgDto
     */
    id: string;
    /**
     * The number of members that are part of this org
     * @type {number}
     * @memberof OrgDto
     */
    memberCount?: number;
    /**
     * The number of teams that are part of this org
     * @type {number}
     * @memberof OrgDto
     */
    teamCount?: number;
}
/**
 * 
 * @export
 * @interface OrgMemberDto
 */
export interface OrgMemberDto {
    /**
     * The org member account id
     * @type {string}
     * @memberof OrgMemberDto
     */
    userId: string;
    /**
     * The role the user has within the org
     * @type {string}
     * @memberof OrgMemberDto
     */
    role: OrgMemberDtoRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OrgMemberDtoRoleEnum {
    Owner = 'owner',
    Member = 'member'
}

/**
 * Parameter.  Parameter indicate a passed string parameter to a service template with an optional default value.
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * Name is the parameter name. must be unique within a task\'s inputs / outputs.
     * @type {string}
     * @memberof Parameter
     */
    name: string;
    /**
     * Default value to use for an input parameter if a value was not supplied.
     * @type {object}
     * @memberof Parameter
     */
    value?: object;
    /**
     * Optional description for input parameter.
     * @type {string}
     * @memberof Parameter
     */
    description?: string;
    /**
     * Load parameters values from a JSON file.
     * @type {string}
     * @memberof Parameter
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface PatchOrgDto
 */
export interface PatchOrgDto {
    /**
     * The pretty name of the org
     * @type {string}
     * @memberof PatchOrgDto
     */
    name: string;
    /**
     * The avatar picture for the Org
     * @type {string}
     * @memberof PatchOrgDto
     */
    picture: string;
    /**
     * The contact email for the organisation
     * @type {string}
     * @memberof PatchOrgDto
     */
    contactEmail: string;
    /**
     * A description of the org
     * @type {string}
     * @memberof PatchOrgDto
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface PatchProjectDto
 */
export interface PatchProjectDto {
    /**
     * The name of the project. Must be unique to a given owner
     * @type {string}
     * @memberof PatchProjectDto
     */
    name: string;
    /**
     * A description of the project
     * @type {string}
     * @memberof PatchProjectDto
     */
    description?: string;
    /**
     * Whether or not a project is publicly viewable
     * @type {boolean}
     * @memberof PatchProjectDto
     */
    _public?: boolean;
}
/**
 * 
 * @export
 * @interface PatchTeamDto
 */
export interface PatchTeamDto {
    /**
     * 
     * @type {string}
     * @memberof PatchTeamDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PatchTeamDto
     */
    description?: string;
}
/**
 * A DAG Workflow.
 * @export
 * @interface PatchWorkflow
 */
export interface PatchWorkflow {
    /**
     * 
     * @type {string}
     * @memberof PatchWorkflow
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkflow
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkflow
     */
    id?: string;
    /**
     * 
     * @type {Arguments}
     * @memberof PatchWorkflow
     */
    inputs?: Arguments;
    /**
     * 
     * @type {Array<Operator>}
     * @memberof PatchWorkflow
     */
    operators: Array<Operator>;
    /**
     * A list of templates. Templates can be Function, DAG or a Workflow.
     * @type {Array<object>}
     * @memberof PatchWorkflow
     */
    templates: Array<object>;
    /**
     * A list of tasks to create a DAG workflow.
     * @type {DAG}
     * @memberof PatchWorkflow
     */
    flow: DAG;
    /**
     * 
     * @type {Arguments}
     * @memberof PatchWorkflow
     */
    outputs?: Arguments;
    /**
     * A list of artifact locations which can be used by flow objects.
     * @type {Array<object>}
     * @memberof PatchWorkflow
     */
    artifactLocations?: Array<object>;
    /**
     * A boolean indicator of whether workflow is public or not
     * @type {boolean}
     * @memberof PatchWorkflow
     */
    _public: boolean;
}
/**
 * 
 * @export
 * @interface PrivateUserDto
 */
export interface PrivateUserDto {
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateUserDto
     */
    picture?: string;
    /**
     * 
     * @type {UserMetadata}
     * @memberof PrivateUserDto
     */
    metadata?: UserMetadata;
}
/**
 * 
 * @export
 * @interface ProjectAccessPolicyDto
 */
export interface ProjectAccessPolicyDto {
    /**
     * The subject the access policy refers to
     * @type {ProjectPolicySubjectDto}
     * @memberof ProjectAccessPolicyDto
     */
    subject: ProjectPolicySubjectDto;
    /**
     * The permission to associate with the policy subject. Can be one of `admin`, `contribute`, or `use`
     * @type {string}
     * @memberof ProjectAccessPolicyDto
     */
    permission: ProjectAccessPolicyDtoPermissionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectAccessPolicyDtoPermissionEnum {
    Admin = 'admin',
    Contribute = 'contribute',
    Read = 'read'
}

/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * The name of the project. Must be unique to a given owner
     * @type {string}
     * @memberof ProjectDto
     */
    name: string;
    /**
     * A description of the project
     * @type {string}
     * @memberof ProjectDto
     */
    description?: string;
    /**
     * Whether or not a project is publicly viewable
     * @type {boolean}
     * @memberof ProjectDto
     */
    _public?: boolean;
    /**
     * The project ID
     * @type {string}
     * @memberof ProjectDto
     */
    id: string;
    /**
     * 
     * @type {AccountPublic}
     * @memberof ProjectDto
     */
    owner: AccountPublic;
    /**
     * 
     * @type {ProjectPermissions}
     * @memberof ProjectDto
     */
    permissions: ProjectPermissions;
    /**
     * The project name in slug format
     * @type {string}
     * @memberof ProjectDto
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface ProjectPermissions
 */
export interface ProjectPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    admin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    contribute: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermissions
     */
    read: boolean;
}
/**
 * 
 * @export
 * @interface ProjectPolicySubjectDto
 */
export interface ProjectPolicySubjectDto {
    /**
     * The type of policy subject. Can be `team`, `org` or `user`
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    type: string;
    /**
     * The ID of the policy subject
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    id: string;
    /**
     * The role within the policy subject that the access policy refers
     * @type {string}
     * @memberof ProjectPolicySubjectDto
     */
    role: string;
}
/**
 * 
 * @export
 * @interface PublicUserDto
 */
export interface PublicUserDto {
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDto
     */
    picture?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    tokenName: string;
}
/**
 * Run Folder Location  This is the folder a workflow will use as it\'s root path when running a simulation. When run on a local machine (using queenbee-luigi for example) the root path should be a path on the user\'s machine. If running on the Pollination platform the `root` value is ignored and the data is persisted to a run specific folder in S3 within the Pollination backend.
 * @export
 * @interface RunFolderLocation
 */
export interface RunFolderLocation {
    /**
     * 
     * @type {string}
     * @memberof RunFolderLocation
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof RunFolderLocation
     */
    name: string;
    /**
     * For a local filesystem this can be \"C:\\Users\\me\\simulations\\test\".            Will be ignored when running on the Pollination platform.
     * @type {string}
     * @memberof RunFolderLocation
     */
    root?: string;
}
/**
 * S3Location  An S3 bucket
 * @export
 * @interface S3Location
 */
export interface S3Location {
    /**
     * 
     * @type {string}
     * @memberof S3Location
     */
    type: string;
    /**
     * Name is a unique identifier for this particular Artifact Location
     * @type {string}
     * @memberof S3Location
     */
    name: string;
    /**
     * The path inside the bucket to source artifacts from.
     * @type {string}
     * @memberof S3Location
     */
    root?: string;
    /**
     * The HTTP endpoint to reach the S3 bucket.
     * @type {string}
     * @memberof S3Location
     */
    endpoint: string;
    /**
     * The name of the S3 bucket on the host server.
     * @type {string}
     * @memberof S3Location
     */
    bucket: string;
    /**
     * Path to the file holding the AccessKey and SecretAccessKey to authenticate to the bucket
     * @type {string}
     * @memberof S3Location
     */
    credentialsPath: string;
}
/**
 * 
 * @export
 * @interface S3UploadRequest
 */
export interface S3UploadRequest {
    /**
     * 
     * @type {string}
     * @memberof S3UploadRequest
     */
    url: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof S3UploadRequest
     */
    fields: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    password: string;
    /**
     * 
     * @type {UserMetadata}
     * @memberof SignUpDto
     */
    metadata: UserMetadata;
}
/**
 * Workflow Status
 * @export
 * @interface SimulationStatus
 */
export interface SimulationStatus {
    /**
     * The status of this task. Can be \"Running\", \"Succeeded\", \"Failed\" or \"Error\"
     * @type {string}
     * @memberof SimulationStatus
     */
    status: string;
    /**
     * Any message produced by the task. Usually error/debugging hints.
     * @type {string}
     * @memberof SimulationStatus
     */
    message?: string;
    /**
     * The time at which the task was started
     * @type {Date}
     * @memberof SimulationStatus
     */
    startedAt: Date;
    /**
     * The time at which the task was completed
     * @type {Date}
     * @memberof SimulationStatus
     */
    finishedAt?: Date;
    /**
     * The ID of the individual workflow run.
     * @type {string}
     * @memberof SimulationStatus
     */
    id: string;
    /**
     * 
     * @type {{ [key: string]: TaskStatus; }}
     * @memberof SimulationStatus
     */
    tasks?: { [key: string]: TaskStatus; };
    /**
     * ID of the account the simulation is running for.
     * @type {string}
     * @memberof SimulationStatus
     */
    ownerId: string;
    /**
     * ID of the project the simulation belongs to
     * @type {string}
     * @memberof SimulationStatus
     */
    projectId: string;
    /**
     * A queenbee workflow payload
     * @type {Workflow}
     * @memberof SimulationStatus
     */
    workflow?: Workflow;
    /**
     * Simulation inputs
     * @type {Arguments}
     * @memberof SimulationStatus
     */
    inputs?: Arguments;
}
/**
 * 
 * @export
 * @interface SubmitSimulationDto
 */
export interface SubmitSimulationDto {
    /**
     * The workflow slug in format {owner}:{workflow_name}
     * @type {string}
     * @memberof SubmitSimulationDto
     */
    workflowSlug: string;
    /**
     * Simulation inputs
     * @type {Arguments}
     * @memberof SubmitSimulationDto
     */
    inputs?: Arguments;
}
/**
 * A Task Status
 * @export
 * @interface TaskStatus
 */
export interface TaskStatus {
    /**
     * The status of this task. Can be \"Running\", \"Succeeded\", \"Failed\" or \"Error\"
     * @type {string}
     * @memberof TaskStatus
     */
    status: string;
    /**
     * Any message produced by the task. Usually error/debugging hints.
     * @type {string}
     * @memberof TaskStatus
     */
    message?: string;
    /**
     * The time at which the task was started
     * @type {Date}
     * @memberof TaskStatus
     */
    startedAt: Date;
    /**
     * The time at which the task was completed
     * @type {Date}
     * @memberof TaskStatus
     */
    finishedAt?: Date;
    /**
     * The task unique ID
     * @type {string}
     * @memberof TaskStatus
     */
    id: string;
    /**
     * A human readable name for the task. Usually defined by the DAG task name but can be extended if the task is part of a loop for example. This name is unique within the boundary of the DAG/Workflow that generated it.
     * @type {string}
     * @memberof TaskStatus
     */
    name: string;
    /**
     * The type of task this status is for. Can be \"Function\", \"DAG\", \"Workflow\" or \"Loop\"
     * @type {string}
     * @memberof TaskStatus
     */
    type: string;
    /**
     * The name of the template that spawned this task
     * @type {string}
     * @memberof TaskStatus
     */
    templateRef: string;
    /**
     * The operator used to run this task. Only applies to Function tasks.
     * @type {Operator}
     * @memberof TaskStatus
     */
    operator?: Operator;
    /**
     * The command used to run this task. Only applies to Function tasks.
     * @type {string}
     * @memberof TaskStatus
     */
    command?: string;
    /**
     * The inputs used by this task
     * @type {Arguments}
     * @memberof TaskStatus
     */
    inputs: Arguments;
    /**
     * The outputs produced by this task
     * @type {Arguments}
     * @memberof TaskStatus
     */
    outputs: Arguments;
    /**
     * This indicates the task ID of the associated template root             task in which this task belongs to. A DAG task will have the id of the             parent DAG for example.
     * @type {string}
     * @memberof TaskStatus
     */
    boundaryId?: string;
    /**
     * A list of child task IDs
     * @type {Array<string>}
     * @memberof TaskStatus
     */
    children: Array<string>;
    /**
     * A list of the last tasks to ran in the context of this task. In the case of a DAG or a workflow this will be the last task that has been executed. It will remain empty for functions.
     * @type {Array<string>}
     * @memberof TaskStatus
     */
    outboundTasks: Array<string>;
}
/**
 * 
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    slug: string;
    /**
     * 
     * @type {TeamOrg}
     * @memberof TeamDto
     */
    org: TeamOrg;
    /**
     * The number of members that are part of this org
     * @type {number}
     * @memberof TeamDto
     */
    memberCount?: number;
}
/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * The team member
     * @type {string}
     * @memberof TeamMemberDto
     */
    userId: string;
    /**
     * The role the user has within the team
     * @type {string}
     * @memberof TeamMemberDto
     */
    role: TeamMemberDtoRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TeamMemberDtoRoleEnum {
    Owner = 'owner',
    Member = 'member'
}

/**
 * 
 * @export
 * @interface TeamOrg
 */
export interface TeamOrg {
    /**
     * The Account name of the org the team belongs to
     * @type {string}
     * @memberof TeamOrg
     */
    accountName: string;
}
/**
 * Accepted request response for existing resource
 * @export
 * @interface UpdateAccepted
 */
export interface UpdateAccepted {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccepted
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface UserMetadata
 */
export interface UserMetadata {
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * A DAG Workflow.
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
    /**
     * 
     * @type {Arguments}
     * @memberof Workflow
     */
    inputs?: Arguments;
    /**
     * 
     * @type {Array<Operator>}
     * @memberof Workflow
     */
    operators: Array<Operator>;
    /**
     * A list of templates. Templates can be Function, DAG or a Workflow.
     * @type {Array<object>}
     * @memberof Workflow
     */
    templates: Array<object>;
    /**
     * A list of tasks to create a DAG workflow.
     * @type {DAG}
     * @memberof Workflow
     */
    flow: DAG;
    /**
     * 
     * @type {Arguments}
     * @memberof Workflow
     */
    outputs?: Arguments;
    /**
     * A list of artifact locations which can be used by flow objects.
     * @type {Array<object>}
     * @memberof Workflow
     */
    artifactLocations?: Array<object>;
}
/**
 * 
 * @export
 * @interface WorkflowAccessPolicyDto
 */
export interface WorkflowAccessPolicyDto {
    /**
     * The subject the access policy refers to
     * @type {WorkflowPolicySubjectDto}
     * @memberof WorkflowAccessPolicyDto
     */
    subject: WorkflowPolicySubjectDto;
    /**
     * The permission to associate with the policy subject. Can be one of `admin`, `contribute`, or `use`
     * @type {string}
     * @memberof WorkflowAccessPolicyDto
     */
    permission: WorkflowAccessPolicyDtoPermissionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkflowAccessPolicyDtoPermissionEnum {
    Admin = 'admin',
    Contribute = 'contribute',
    Use = 'use'
}

/**
 * A DAG Workflow.
 * @export
 * @interface WorkflowDto
 */
export interface WorkflowDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    id?: string;
    /**
     * 
     * @type {Arguments}
     * @memberof WorkflowDto
     */
    inputs?: Arguments;
    /**
     * 
     * @type {Array<Operator>}
     * @memberof WorkflowDto
     */
    operators: Array<Operator>;
    /**
     * A list of templates. Templates can be Function, DAG or a Workflow.
     * @type {Array<object>}
     * @memberof WorkflowDto
     */
    templates: Array<object>;
    /**
     * A list of tasks to create a DAG workflow.
     * @type {DAG}
     * @memberof WorkflowDto
     */
    flow: DAG;
    /**
     * 
     * @type {Arguments}
     * @memberof WorkflowDto
     */
    outputs?: Arguments;
    /**
     * A list of artifact locations which can be used by flow objects.
     * @type {Array<object>}
     * @memberof WorkflowDto
     */
    artifactLocations?: Array<object>;
    /**
     * A boolean indicator of whether workflow is public or not
     * @type {boolean}
     * @memberof WorkflowDto
     */
    _public: boolean;
    /**
     * 
     * @type {AccountPublic}
     * @memberof WorkflowDto
     */
    owner: AccountPublic;
    /**
     * The workflow slug in format {owner}:{workflow_name}
     * @type {string}
     * @memberof WorkflowDto
     */
    slug: string;
    /**
     * The permissions the current user has on the workflow.
     * @type {WorkflowPermissions}
     * @memberof WorkflowDto
     */
    permissions: WorkflowPermissions;
}
/**
 * 
 * @export
 * @interface WorkflowPermissions
 */
export interface WorkflowPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowPermissions
     */
    admin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowPermissions
     */
    contribute: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowPermissions
     */
    use: boolean;
}
/**
 * 
 * @export
 * @interface WorkflowPolicySubjectDto
 */
export interface WorkflowPolicySubjectDto {
    /**
     * The type of policy subject. Can be `team`, `org` or `user`
     * @type {string}
     * @memberof WorkflowPolicySubjectDto
     */
    type: string;
    /**
     * The ID of the policy subject
     * @type {string}
     * @memberof WorkflowPolicySubjectDto
     */
    id: string;
    /**
     * The role within the policy subject that the access policy refers
     * @type {string}
     * @memberof WorkflowPolicySubjectDto
     */
    role: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 * @hidden
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAccount.');
            }
            const localVarPath = `/accounts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 * @hidden
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPublic> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccount(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 * @hidden
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieve a workflow by name
         * @summary Get an account by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(name: string, options?: any) {
            return AccountsApiFp(configuration).getAccount(name, options)(axios, basePath);
        },
    };
};

/**
 * AccountsApi - interface
 * @export
 * @interface AccountsApi
 */
export interface AccountsApiInterface {
    /**
     * Retrieve a workflow by name
     * @summary Get an account by name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getAccount(name: string, options?: any): AxiosPromise<AccountPublic>;

}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI implements AccountsApiInterface {
    /**
     * Retrieve a workflow by name
     * @summary Get an account by name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(name: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccount(name, options)(this.axios, this.basePath);
    }

}


/**
 * ArtifactsApi - axios parameter creator
 * @export
 * @hidden
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'keyRequest' is not null or undefined
            if (keyRequest === null || keyRequest === undefined) {
                throw new RequiredError('keyRequest','Required parameter keyRequest was null or undefined when calling createArtifact.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof keyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(keyRequest !== undefined ? keyRequest : {}) : (keyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteArtifact.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifacts.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listArtifacts.');
            }
            const localVarPath = `/projects/{owner}/{name}/artifacts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 * @hidden
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3UploadRequest> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).createArtifact(owner, name, keyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).deleteArtifact(owner, name, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileMeta>> {
            const localVarAxiosArgs = ArtifactsApiAxiosParamCreator(configuration).listArtifacts(owner, name, page, perPage, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 * @hidden
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new artifact.
         * @summary Get an Artifact upload link.
         * @param {string} owner 
         * @param {string} name 
         * @param {KeyRequest} keyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any) {
            return ArtifactsApiFp(configuration).createArtifact(owner, name, keyRequest, options)(axios, basePath);
        },
        /**
         * Delete one or multiple artifacts based on key prefix
         * @summary Delete one or many artifacts by key/prefix
         * @param {string} owner 
         * @param {string} name 
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any) {
            return ArtifactsApiFp(configuration).deleteArtifact(owner, name, path, options)(axios, basePath);
        },
        /**
         * Retrieve a list of artifacts.
         * @summary List artifacts in a project folder
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [path] The path to an artifact within a project folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any) {
            return ArtifactsApiFp(configuration).listArtifacts(owner, name, page, perPage, path, options)(axios, basePath);
        },
    };
};

/**
 * ArtifactsApi - interface
 * @export
 * @interface ArtifactsApi
 */
export interface ArtifactsApiInterface {
    /**
     * Create a new artifact.
     * @summary Get an Artifact upload link.
     * @param {string} owner 
     * @param {string} name 
     * @param {KeyRequest} keyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any): AxiosPromise<S3UploadRequest>;

    /**
     * Delete one or multiple artifacts based on key prefix
     * @summary Delete one or many artifacts by key/prefix
     * @param {string} owner 
     * @param {string} name 
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Retrieve a list of artifacts.
     * @summary List artifacts in a project folder
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApiInterface
     */
    listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any): AxiosPromise<Array<FileMeta>>;

}

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI implements ArtifactsApiInterface {
    /**
     * Create a new artifact.
     * @summary Get an Artifact upload link.
     * @param {string} owner 
     * @param {string} name 
     * @param {KeyRequest} keyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public createArtifact(owner: string, name: string, keyRequest: KeyRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).createArtifact(owner, name, keyRequest, options)(this.axios, this.basePath);
    }

    /**
     * Delete one or multiple artifacts based on key prefix
     * @summary Delete one or many artifacts by key/prefix
     * @param {string} owner 
     * @param {string} name 
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifact(owner: string, name: string, path?: Array<string>, options?: any) {
        return ArtifactsApiFp(this.configuration).deleteArtifact(owner, name, path, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of artifacts.
     * @summary List artifacts in a project folder
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [path] The path to an artifact within a project folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public listArtifacts(owner: string, name: string, page?: number, perPage?: number, path?: Array<string>, options?: any) {
        return ArtifactsApiFp(this.configuration).listArtifacts(owner, name, page, perPage, path, options)(this.axios, this.basePath);
    }

}


/**
 * OrgsApi - axios parameter creator
 * @export
 * @hidden
 */
export const OrgsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options: any = {}): RequestArgs {
            // verify required parameter 'createOrgDto' is not null or undefined
            if (createOrgDto === null || createOrgDto === undefined) {
                throw new RequiredError('createOrgDto','Required parameter createOrgDto was null or undefined when calling createOrg.');
            }
            const localVarPath = `/orgs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createOrgDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createOrgDto !== undefined ? createOrgDto : {}) : (createOrgDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteOrgMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteOrgMember.');
            }
            const localVarPath = `/orgs/{name}/members/{username}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOrgMembers.');
            }
            const localVarPath = `/orgs/{name}/members`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/orgs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (member) {
                localVarQueryParameter['member'] = member;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateOrg.');
            }
            // verify required parameter 'patchOrgDto' is not null or undefined
            if (patchOrgDto === null || patchOrgDto === undefined) {
                throw new RequiredError('patchOrgDto','Required parameter patchOrgDto was null or undefined when calling updateOrg.');
            }
            const localVarPath = `/orgs/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchOrgDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOrgDto !== undefined ? patchOrgDto : {}) : (patchOrgDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertOrgMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling upsertOrgMember.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling upsertOrgMember.');
            }
            const localVarPath = `/orgs/{name}/members/{username}/{role}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgsApi - functional programming interface
 * @export
 * @hidden
 */
export const OrgsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).createOrg(createOrgDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).deleteOrg(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).deleteOrgMember(name, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).getOrg(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgMemberDto>> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).getOrgMembers(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgDto>> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).listOrgs(page, perPage, name, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).updateOrg(name, patchOrgDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = OrgsApiAxiosParamCreator(configuration).upsertOrgMember(name, username, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrgsApi - factory interface
 * @export
 * @hidden
 */
export const OrgsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new org.
         * @summary Create an Org
         * @param {CreateOrgDto} createOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgDto: CreateOrgDto, options?: any) {
            return OrgsApiFp(configuration).createOrg(createOrgDto, options)(axios, basePath);
        },
        /**
         * Delete a org (must have `admin` permission)
         * @summary Delete an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(name: string, options?: any) {
            return OrgsApiFp(configuration).deleteOrg(name, options)(axios, basePath);
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove an Org member
         * @param {string} name 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgMember(name: string, username: string, options?: any) {
            return OrgsApiFp(configuration).deleteOrgMember(name, username, options)(axios, basePath);
        },
        /**
         * Retrieve a org by name
         * @summary Get an Org
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(name: string, options?: any) {
            return OrgsApiFp(configuration).getOrg(name, options)(axios, basePath);
        },
        /**
         * Retrieve a org\'s members
         * @summary List an Org\'s members
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMembers(name: string, options?: any) {
            return OrgsApiFp(configuration).getOrgMembers(name, options)(axios, basePath);
        },
        /**
         * search for orgs using query parameters
         * @summary List Orgs
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
            return OrgsApiFp(configuration).listOrgs(page, perPage, name, member, options)(axios, basePath);
        },
        /**
         * Update a org (must have org `owner` role)
         * @summary Update an Org
         * @param {string} name 
         * @param {PatchOrgDto} patchOrgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any) {
            return OrgsApiFp(configuration).updateOrg(name, patchOrgDto, options)(axios, basePath);
        },
        /**
         * Upsert a member role to the org (must have org `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} name 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any) {
            return OrgsApiFp(configuration).upsertOrgMember(name, username, role, options)(axios, basePath);
        },
    };
};

/**
 * OrgsApi - interface
 * @export
 * @interface OrgsApi
 */
export interface OrgsApiInterface {
    /**
     * Create a new org.
     * @summary Create an Org
     * @param {CreateOrgDto} createOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    createOrg(createOrgDto: CreateOrgDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Delete a org (must have `admin` permission)
     * @summary Delete an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    deleteOrg(name: string, options?: any): AxiosPromise<{}>;

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove an Org member
     * @param {string} name 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    deleteOrgMember(name: string, username: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a org by name
     * @summary Get an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    getOrg(name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a org\'s members
     * @summary List an Org\'s members
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    getOrgMembers(name: string, options?: any): AxiosPromise<Array<OrgMemberDto>>;

    /**
     * search for orgs using query parameters
     * @summary List Orgs
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): AxiosPromise<Array<OrgDto>>;

    /**
     * Update a org (must have org `owner` role)
     * @summary Update an Org
     * @param {string} name 
     * @param {PatchOrgDto} patchOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a member role to the org (must have org `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} name 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApiInterface
     */
    upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * OrgsApi - object-oriented interface
 * @export
 * @class OrgsApi
 * @extends {BaseAPI}
 */
export class OrgsApi extends BaseAPI implements OrgsApiInterface {
    /**
     * Create a new org.
     * @summary Create an Org
     * @param {CreateOrgDto} createOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public createOrg(createOrgDto: CreateOrgDto, options?: any) {
        return OrgsApiFp(this.configuration).createOrg(createOrgDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete a org (must have `admin` permission)
     * @summary Delete an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public deleteOrg(name: string, options?: any) {
        return OrgsApiFp(this.configuration).deleteOrg(name, options)(this.axios, this.basePath);
    }

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove an Org member
     * @param {string} name 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public deleteOrgMember(name: string, username: string, options?: any) {
        return OrgsApiFp(this.configuration).deleteOrgMember(name, username, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a org by name
     * @summary Get an Org
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrg(name: string, options?: any) {
        return OrgsApiFp(this.configuration).getOrg(name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a org\'s members
     * @summary List an Org\'s members
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgMembers(name: string, options?: any) {
        return OrgsApiFp(this.configuration).getOrgMembers(name, options)(this.axios, this.basePath);
    }

    /**
     * search for orgs using query parameters
     * @summary List Orgs
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public listOrgs(page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
        return OrgsApiFp(this.configuration).listOrgs(page, perPage, name, member, options)(this.axios, this.basePath);
    }

    /**
     * Update a org (must have org `owner` role)
     * @summary Update an Org
     * @param {string} name 
     * @param {PatchOrgDto} patchOrgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrg(name: string, patchOrgDto: PatchOrgDto, options?: any) {
        return OrgsApiFp(this.configuration).updateOrg(name, patchOrgDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a member role to the org (must have org `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} name 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public upsertOrgMember(name: string, username: string, role: 'owner' | 'member', options?: any) {
        return OrgsApiFp(this.configuration).upsertOrgMember(name, username, role, options)(this.axios, this.basePath);
    }

}


/**
 * ProjectsApi - axios parameter creator
 * @export
 * @hidden
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'patchProjectDto' is not null or undefined
            if (patchProjectDto === null || patchProjectDto === undefined) {
                throw new RequiredError('patchProjectDto','Required parameter patchProjectDto was null or undefined when calling createProject.');
            }
            const localVarPath = `/projects/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchProjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchProjectDto !== undefined ? patchProjectDto : {}) : (patchProjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectOrgPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteProjectOrgPermission.');
            }
            // verify required parameter 'projectPolicySubjectDto' is not null or undefined
            if (projectPolicySubjectDto === null || projectPolicySubjectDto === undefined) {
                throw new RequiredError('projectPolicySubjectDto','Required parameter projectPolicySubjectDto was null or undefined when calling deleteProjectOrgPermission.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof projectPolicySubjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectPolicySubjectDto !== undefined ? projectPolicySubjectDto : {}) : (projectPolicySubjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectAccessPermissions.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getProjectAccessPermissions.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/projects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (owner) {
                localVarQueryParameter['owner'] = owner;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (operator) {
                localVarQueryParameter['operator'] = operator;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling update.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling update.');
            }
            // verify required parameter 'patchProjectDto' is not null or undefined
            if (patchProjectDto === null || patchProjectDto === undefined) {
                throw new RequiredError('patchProjectDto','Required parameter patchProjectDto was null or undefined when calling update.');
            }
            const localVarPath = `/projects/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchProjectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchProjectDto !== undefined ? patchProjectDto : {}) : (patchProjectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling upsertProjectPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertProjectPermission.');
            }
            // verify required parameter 'projectAccessPolicyDto' is not null or undefined
            if (projectAccessPolicyDto === null || projectAccessPolicyDto === undefined) {
                throw new RequiredError('projectAccessPolicyDto','Required parameter projectAccessPolicyDto was null or undefined when calling upsertProjectPermission.');
            }
            const localVarPath = `/projects/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof projectAccessPolicyDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectAccessPolicyDto !== undefined ? projectAccessPolicyDto : {}) : (projectAccessPolicyDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 * @hidden
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).createProject(owner, patchProjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).deleteProject(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProject(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectAccessPolicyDto>> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProjectAccessPermissions(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).listProjects(page, perPage, id, name, owner, _public, operator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).update(owner, name, patchProjectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 * @hidden
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new project.
         * @summary Create a Project
         * @param {string} owner 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any) {
            return ProjectsApiFp(configuration).createProject(owner, patchProjectDto, options)(axios, basePath);
        },
        /**
         * Delete a project (must have `admin` permission)
         * @summary Delete a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProject(owner, name, options)(axios, basePath);
        },
        /**
         * Delete a project\'s access policy (must have `admin` permission)
         * @summary Remove a Project permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any) {
            return ProjectsApiFp(configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options)(axios, basePath);
        },
        /**
         * Retrieve a project by name
         * @summary Get a project
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getProject(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve a project\'s access permissions (must have `contribute` permission)
         * @summary Get a project\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAccessPermissions(owner: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectAccessPermissions(owner, name, options)(axios, basePath);
        },
        /**
         * search for projects using query parameters
         * @summary List Projects
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
            return ProjectsApiFp(configuration).listProjects(page, perPage, id, name, owner, _public, operator, options)(axios, basePath);
        },
        /**
         * Update a project (must have `contribute` permission)
         * @summary Update a Project
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchProjectDto} patchProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any) {
            return ProjectsApiFp(configuration).update(owner, name, patchProjectDto, options)(axios, basePath);
        },
        /**
         * Upsert a project\'s access policy (must have `admin` permission)
         * @summary Upsert a new permission to a project
         * @param {string} owner 
         * @param {string} name 
         * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any) {
            return ProjectsApiFp(configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options)(axios, basePath);
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * Create a new project.
     * @summary Create a Project
     * @param {string} owner 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Delete a project (must have `admin` permission)
     * @summary Delete a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    deleteProject(owner: string, name: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a project\'s access policy (must have `admin` permission)
     * @summary Remove a Project permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a project by name
     * @summary Get a project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    getProject(owner: string, name: string, options?: any): AxiosPromise<object>;

    /**
     * Retrieve a project\'s access permissions (must have `contribute` permission)
     * @summary Get a project\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    getProjectAccessPermissions(owner: string, name: string, options?: any): AxiosPromise<Array<ProjectAccessPolicyDto>>;

    /**
     * search for projects using query parameters
     * @summary List Projects
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): AxiosPromise<Array<ProjectDto>>;

    /**
     * Update a project (must have `contribute` permission)
     * @summary Update a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a project\'s access policy (must have `admin` permission)
     * @summary Upsert a new permission to a project
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Create a new project.
     * @summary Create a Project
     * @param {string} owner 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(owner: string, patchProjectDto: PatchProjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).createProject(owner, patchProjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete a project (must have `admin` permission)
     * @summary Delete a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Delete a project\'s access policy (must have `admin` permission)
     * @summary Remove a Project permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectPolicySubjectDto} projectPolicySubjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectOrgPermission(owner: string, name: string, projectPolicySubjectDto: ProjectPolicySubjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjectOrgPermission(owner, name, projectPolicySubjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a project by name
     * @summary Get a project
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a project\'s access permissions (must have `contribute` permission)
     * @summary Get a project\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectAccessPermissions(owner: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectAccessPermissions(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * search for projects using query parameters
     * @summary List Projects
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
        return ProjectsApiFp(this.configuration).listProjects(page, perPage, id, name, owner, _public, operator, options)(this.axios, this.basePath);
    }

    /**
     * Update a project (must have `contribute` permission)
     * @summary Update a Project
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchProjectDto} patchProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public update(owner: string, name: string, patchProjectDto: PatchProjectDto, options?: any) {
        return ProjectsApiFp(this.configuration).update(owner, name, patchProjectDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a project\'s access policy (must have `admin` permission)
     * @summary Upsert a new permission to a project
     * @param {string} owner 
     * @param {string} name 
     * @param {ProjectAccessPolicyDto} projectAccessPolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public upsertProjectPermission(owner: string, name: string, projectAccessPolicyDto: ProjectAccessPolicyDto, options?: any) {
        return ProjectsApiFp(this.configuration).upsertProjectPermission(owner, name, projectAccessPolicyDto, options)(this.axios, this.basePath);
    }

}


/**
 * SimulationsApi - axios parameter creator
 * @export
 * @hidden
 */
export const SimulationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createSimulation.');
            }
            // verify required parameter 'submitSimulationDto' is not null or undefined
            if (submitSimulationDto === null || submitSimulationDto === undefined) {
                throw new RequiredError('submitSimulationDto','Required parameter submitSimulationDto was null or undefined when calling createSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof submitSimulationDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(submitSimulationDto !== undefined ? submitSimulationDto : {}) : (submitSimulationDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationInputs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationInputs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationInputs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/inputs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationLogs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationLogs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/logs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationOutputs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationOutputs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationOutputs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/outputs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling getSimulationTaskLogs.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getSimulationTaskLogs.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/task/{task_id}/logs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [workflow] The ID of the workflow used for this simulation
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, workflow?: Array<string>, status?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSimulations.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listSimulations.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (workflow) {
                localVarQueryParameter['workflow'] = workflow;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resubmitSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resubmitSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling resubmitSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/re-submit`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resumeSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling resumeSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling suspendSimulation.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling suspendSimulation.');
            }
            // verify required parameter 'simulationId' is not null or undefined
            if (simulationId === null || simulationId === undefined) {
                throw new RequiredError('simulationId','Required parameter simulationId was null or undefined when calling suspendSimulation.');
            }
            const localVarPath = `/projects/{owner}/{name}/simulations/{simulation_id}/suspend`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"simulation_id"}}`, encodeURIComponent(String(simulationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationsApi - functional programming interface
 * @export
 * @hidden
 */
export const SimulationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).createSimulation(owner, name, submitSimulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationStatus> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationInputs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationLogs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationOutputs(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [workflow] The ID of the workflow used for this simulation
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, workflow?: Array<string>, status?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SimulationStatus>> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).listSimulations(owner, name, page, perPage, id, workflow, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).resubmitSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).resumeSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accepted> {
            const localVarAxiosArgs = SimulationsApiAxiosParamCreator(configuration).suspendSimulation(owner, name, simulationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SimulationsApi - factory interface
 * @export
 * @hidden
 */
export const SimulationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new simulation.
         * @summary Schedule a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {SubmitSimulationDto} submitSimulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, options?: any) {
            return SimulationsApiFp(configuration).createSimulation(owner, name, submitSimulationDto, options)(axios, basePath);
        },
        /**
         * Retrieve a simulation.
         * @summary Get a Simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulation(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation inputs
         * @summary Get simulation inputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationInputs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationInputs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation logs
         * @summary Get simulation logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationLogs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationLogs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation outputs
         * @summary Get simulation outputs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationOutputs(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * get simulation task logs
         * @summary Get a simulation task\'s logs
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any) {
            return SimulationsApiFp(configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options)(axios, basePath);
        },
        /**
         * Retrieve a list of simulations.
         * @summary List simulations
         * @param {string} owner 
         * @param {string} name 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a simulation to search for
         * @param {Array<string>} [workflow] The ID of the workflow used for this simulation
         * @param {Array<string>} [status] The status of the simulation to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, workflow?: Array<string>, status?: Array<string>, options?: any) {
            return SimulationsApiFp(configuration).listSimulations(owner, name, page, perPage, id, workflow, status, options)(axios, basePath);
        },
        /**
         * re-submit a simulation
         * @summary re-submit a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).resubmitSimulation(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * resume a simulation
         * @summary resume a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).resumeSimulation(owner, name, simulationId, options)(axios, basePath);
        },
        /**
         * Suspend a simulation.
         * @summary Suspend a simulation
         * @param {string} owner 
         * @param {string} name 
         * @param {string} simulationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSimulation(owner: string, name: string, simulationId: string, options?: any) {
            return SimulationsApiFp(configuration).suspendSimulation(owner, name, simulationId, options)(axios, basePath);
        },
    };
};

/**
 * SimulationsApi - interface
 * @export
 * @interface SimulationsApi
 */
export interface SimulationsApiInterface {
    /**
     * Create a new simulation.
     * @summary Schedule a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {SubmitSimulationDto} submitSimulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Retrieve a simulation.
     * @summary Get a Simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<SimulationStatus>;

    /**
     * get simulation inputs
     * @summary Get simulation inputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationInputs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation logs
     * @summary Get simulation logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationLogs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation outputs
     * @summary Get simulation outputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<object>;

    /**
     * get simulation task logs
     * @summary Get a simulation task\'s logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any): AxiosPromise<string>;

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a simulation to search for
     * @param {Array<string>} [workflow] The ID of the workflow used for this simulation
     * @param {Array<string>} [status] The status of the simulation to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, workflow?: Array<string>, status?: Array<string>, options?: any): AxiosPromise<Array<SimulationStatus>>;

    /**
     * re-submit a simulation
     * @summary re-submit a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    resubmitSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<CreatedContent>;

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    resumeSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<Accepted>;

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApiInterface
     */
    suspendSimulation(owner: string, name: string, simulationId: string, options?: any): AxiosPromise<Accepted>;

}

/**
 * SimulationsApi - object-oriented interface
 * @export
 * @class SimulationsApi
 * @extends {BaseAPI}
 */
export class SimulationsApi extends BaseAPI implements SimulationsApiInterface {
    /**
     * Create a new simulation.
     * @summary Schedule a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {SubmitSimulationDto} submitSimulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public createSimulation(owner: string, name: string, submitSimulationDto: SubmitSimulationDto, options?: any) {
        return SimulationsApiFp(this.configuration).createSimulation(owner, name, submitSimulationDto, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a simulation.
     * @summary Get a Simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation inputs
     * @summary Get simulation inputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationInputs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationInputs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation logs
     * @summary Get simulation logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationLogs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationLogs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation outputs
     * @summary Get simulation outputs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationOutputs(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationOutputs(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * get simulation task logs
     * @summary Get a simulation task\'s logs
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public getSimulationTaskLogs(owner: string, name: string, simulationId: string, taskId: string, options?: any) {
        return SimulationsApiFp(this.configuration).getSimulationTaskLogs(owner, name, simulationId, taskId, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a list of simulations.
     * @summary List simulations
     * @param {string} owner 
     * @param {string} name 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a simulation to search for
     * @param {Array<string>} [workflow] The ID of the workflow used for this simulation
     * @param {Array<string>} [status] The status of the simulation to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public listSimulations(owner: string, name: string, page?: number, perPage?: number, id?: Array<string>, workflow?: Array<string>, status?: Array<string>, options?: any) {
        return SimulationsApiFp(this.configuration).listSimulations(owner, name, page, perPage, id, workflow, status, options)(this.axios, this.basePath);
    }

    /**
     * re-submit a simulation
     * @summary re-submit a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public resubmitSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).resubmitSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * resume a simulation
     * @summary resume a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public resumeSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).resumeSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

    /**
     * Suspend a simulation.
     * @summary Suspend a simulation
     * @param {string} owner 
     * @param {string} name 
     * @param {string} simulationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationsApi
     */
    public suspendSimulation(owner: string, name: string, simulationId: string, options?: any) {
        return SimulationsApiFp(this.configuration).suspendSimulation(owner, name, simulationId, options)(this.axios, this.basePath);
    }

}


/**
 * TeamsApi - axios parameter creator
 * @export
 * @hidden
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling createTeam.');
            }
            // verify required parameter 'patchTeamDto' is not null or undefined
            if (patchTeamDto === null || patchTeamDto === undefined) {
                throw new RequiredError('patchTeamDto','Required parameter patchTeamDto was null or undefined when calling createTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchTeamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchTeamDto !== undefined ? patchTeamDto : {}) : (patchTeamDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling deleteOrgTeamMember.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling deleteOrgTeamMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteOrgTeamMember.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members/{username}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling getOrgTeamMembers.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling getOrgTeamMembers.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling getTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling getTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling listOrgTeams.');
            }
            const localVarPath = `/orgs/{org_name}/teams`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (member) {
                localVarQueryParameter['member'] = member;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'patchTeamDto' is not null or undefined
            if (patchTeamDto === null || patchTeamDto === undefined) {
                throw new RequiredError('patchTeamDto','Required parameter patchTeamDto was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchTeamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchTeamDto !== undefined ? patchTeamDto : {}) : (patchTeamDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options: any = {}): RequestArgs {
            // verify required parameter 'orgName' is not null or undefined
            if (orgName === null || orgName === undefined) {
                throw new RequiredError('orgName','Required parameter orgName was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'teamSlug' is not null or undefined
            if (teamSlug === null || teamSlug === undefined) {
                throw new RequiredError('teamSlug','Required parameter teamSlug was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling upsertOrgTeamMember.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling upsertOrgTeamMember.');
            }
            const localVarPath = `/orgs/{org_name}/teams/{team_slug}/members/{username}/{role}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)))
                .replace(`{${"team_slug"}}`, encodeURIComponent(String(teamSlug)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 * @hidden
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).createTeam(orgName, patchTeamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).deleteOrgTeamMember(orgName, teamSlug, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).deleteTeam(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMemberDto>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getOrgTeamMembers(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getTeam(orgName, teamSlug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).listOrgTeams(orgName, page, perPage, name, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).updateTeam(orgName, teamSlug, patchTeamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 * @hidden
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new team (must be parent org member)
         * @summary Create a Team
         * @param {string} orgName 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any) {
            return TeamsApiFp(configuration).createTeam(orgName, patchTeamDto, options)(axios, basePath);
        },
        /**
         * Remove a member from the org (must have org `owner` role)
         * @summary Remove a team member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any) {
            return TeamsApiFp(configuration).deleteOrgTeamMember(orgName, teamSlug, username, options)(axios, basePath);
        },
        /**
         * Delete a team (must have team or org `owner` role)
         * @summary Delete a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).deleteTeam(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * Retrieve a tean\'s members
         * @summary List a team\'s members
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgTeamMembers(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).getOrgTeamMembers(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * Retrieve a team by name
         * @summary Get a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(orgName: string, teamSlug: string, options?: any) {
            return TeamsApiFp(configuration).getTeam(orgName, teamSlug, options)(axios, basePath);
        },
        /**
         * search for orgs using query parameters
         * @summary List Teams
         * @param {string} orgName 
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [member] The ID of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
            return TeamsApiFp(configuration).listOrgTeams(orgName, page, perPage, name, member, options)(axios, basePath);
        },
        /**
         * Update a team (must have team or org `owner` role)
         * @summary Update a Team
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {PatchTeamDto} patchTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any) {
            return TeamsApiFp(configuration).updateTeam(orgName, teamSlug, patchTeamDto, options)(axios, basePath);
        },
        /**
         * Upsert a member role to the team (must have org or team `owner` role)
         * @summary Add or update the role of an Org Member
         * @param {string} orgName 
         * @param {string} teamSlug 
         * @param {string} username 
         * @param {'owner' | 'member'} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any) {
            return TeamsApiFp(configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options)(axios, basePath);
        },
    };
};

/**
 * TeamsApi - interface
 * @export
 * @interface TeamsApi
 */
export interface TeamsApiInterface {
    /**
     * Create a new team (must be parent org member)
     * @summary Create a Team
     * @param {string} orgName 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove a team member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a team (must have team or org `owner` role)
     * @summary Delete a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    deleteTeam(orgName: string, teamSlug: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a tean\'s members
     * @summary List a team\'s members
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    getOrgTeamMembers(orgName: string, teamSlug: string, options?: any): AxiosPromise<Array<TeamMemberDto>>;

    /**
     * Retrieve a team by name
     * @summary Get a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    getTeam(orgName: string, teamSlug: string, options?: any): AxiosPromise<object>;

    /**
     * search for orgs using query parameters
     * @summary List Teams
     * @param {string} orgName 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any): AxiosPromise<Array<TeamDto>>;

    /**
     * Update a team (must have team or org `owner` role)
     * @summary Update a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a member role to the team (must have org or team `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApiInterface
     */
    upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI implements TeamsApiInterface {
    /**
     * Create a new team (must be parent org member)
     * @summary Create a Team
     * @param {string} orgName 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public createTeam(orgName: string, patchTeamDto: PatchTeamDto, options?: any) {
        return TeamsApiFp(this.configuration).createTeam(orgName, patchTeamDto, options)(this.axios, this.basePath);
    }

    /**
     * Remove a member from the org (must have org `owner` role)
     * @summary Remove a team member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteOrgTeamMember(orgName: string, teamSlug: string, username: string, options?: any) {
        return TeamsApiFp(this.configuration).deleteOrgTeamMember(orgName, teamSlug, username, options)(this.axios, this.basePath);
    }

    /**
     * Delete a team (must have team or org `owner` role)
     * @summary Delete a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).deleteTeam(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a tean\'s members
     * @summary List a team\'s members
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getOrgTeamMembers(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).getOrgTeamMembers(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a team by name
     * @summary Get a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeam(orgName: string, teamSlug: string, options?: any) {
        return TeamsApiFp(this.configuration).getTeam(orgName, teamSlug, options)(this.axios, this.basePath);
    }

    /**
     * search for orgs using query parameters
     * @summary List Teams
     * @param {string} orgName 
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [member] The ID of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public listOrgTeams(orgName: string, page?: number, perPage?: number, name?: Array<string>, member?: Array<string>, options?: any) {
        return TeamsApiFp(this.configuration).listOrgTeams(orgName, page, perPage, name, member, options)(this.axios, this.basePath);
    }

    /**
     * Update a team (must have team or org `owner` role)
     * @summary Update a Team
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {PatchTeamDto} patchTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeam(orgName: string, teamSlug: string, patchTeamDto: PatchTeamDto, options?: any) {
        return TeamsApiFp(this.configuration).updateTeam(orgName, teamSlug, patchTeamDto, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a member role to the team (must have org or team `owner` role)
     * @summary Add or update the role of an Org Member
     * @param {string} orgName 
     * @param {string} teamSlug 
     * @param {string} username 
     * @param {'owner' | 'member'} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public upsertOrgTeamMember(orgName: string, teamSlug: string, username: string, role: 'owner' | 'member', options?: any) {
        return TeamsApiFp(this.configuration).upsertOrgTeamMember(orgName, teamSlug, username, role, options)(this.axios, this.basePath);
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 * @hidden
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options: any = {}): RequestArgs {
            // verify required parameter 'emailRequest' is not null or undefined
            if (emailRequest === null || emailRequest === undefined) {
                throw new RequiredError('emailRequest','Required parameter emailRequest was null or undefined when calling changePassword.');
            }
            const localVarPath = `/user/change_password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof emailRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(emailRequest !== undefined ? emailRequest : {}) : (emailRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options: any = {}): RequestArgs {
            const localVarPath = `/user/roles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options: any = {}): RequestArgs {
            const localVarPath = `/user/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options: any = {}): RequestArgs {
            // verify required parameter 'loginDto' is not null or undefined
            if (loginDto === null || loginDto === undefined) {
                throw new RequiredError('loginDto','Required parameter loginDto was null or undefined when calling login.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof loginDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(loginDto !== undefined ? loginDto : {}) : (loginDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options: any = {}): RequestArgs {
            // verify required parameter 'signUpDto' is not null or undefined
            if (signUpDto === null || signUpDto === undefined) {
                throw new RequiredError('signUpDto','Required parameter signUpDto was null or undefined when calling signup.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof signUpDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUpDto !== undefined ? signUpDto : {}) : (signUpDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options: any = {}): RequestArgs {
            // verify required parameter 'createTokenDto' is not null or undefined
            if (createTokenDto === null || createTokenDto === undefined) {
                throw new RequiredError('createTokenDto','Required parameter createTokenDto was null or undefined when calling upsertRefreshToken.');
            }
            const localVarPath = `/user/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createTokenDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTokenDto !== undefined ? createTokenDto : {}) : (createTokenDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 * @hidden
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).changePassword(emailRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateUserDto> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getMe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshTokenDto>> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).listRefreshTokens(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginToken> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).login(loginDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).signup(signUpDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).upsertRefreshToken(createTokenDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 * @hidden
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Make a password change request
         * @summary Make a password change request
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(emailRequest: EmailRequest, options?: any) {
            return UserApiFp(configuration).changePassword(emailRequest, options)(axios, basePath);
        },
        /**
         * Get authenticated user profile
         * @summary Get authenticated user profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any) {
            return UserApiFp(configuration).getMe(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get the authenticated user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any) {
            return UserApiFp(configuration).getRoles(options)(axios, basePath);
        },
        /**
         * Get a list of token names
         * @summary Get a list of token names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshTokens(options?: any) {
            return UserApiFp(configuration).listRefreshTokens(options)(axios, basePath);
        },
        /**
         * Login a user
         * @summary Login to the platform and get a JWT back
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any) {
            return UserApiFp(configuration).login(loginDto, options)(axios, basePath);
        },
        /**
         * Sign Up a new user
         * @summary Sign Up to the platform!
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpDto: SignUpDto, options?: any) {
            return UserApiFp(configuration).signup(signUpDto, options)(axios, basePath);
        },
        /**
         * Get refresh token and delete previous one if it exists
         * @summary Get refresh token and delete previous one if it exists
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any) {
            return UserApiFp(configuration).upsertRefreshToken(createTokenDto, options)(axios, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Make a password change request
     * @summary Make a password change request
     * @param {EmailRequest} emailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    changePassword(emailRequest: EmailRequest, options?: any): AxiosPromise<object>;

    /**
     * Get authenticated user profile
     * @summary Get authenticated user profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getMe(options?: any): AxiosPromise<PrivateUserDto>;

    /**
     * 
     * @summary Get the authenticated user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getRoles(options?: any): AxiosPromise<Array<string>>;

    /**
     * Get a list of token names
     * @summary Get a list of token names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listRefreshTokens(options?: any): AxiosPromise<Array<RefreshTokenDto>>;

    /**
     * Login a user
     * @summary Login to the platform and get a JWT back
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    login(loginDto: LoginDto, options?: any): AxiosPromise<LoginToken>;

    /**
     * Sign Up a new user
     * @summary Sign Up to the platform!
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    signup(signUpDto: SignUpDto, options?: any): AxiosPromise<object>;

    /**
     * Get refresh token and delete previous one if it exists
     * @summary Get refresh token and delete previous one if it exists
     * @param {CreateTokenDto} createTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any): AxiosPromise<string>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Make a password change request
     * @summary Make a password change request
     * @param {EmailRequest} emailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePassword(emailRequest: EmailRequest, options?: any) {
        return UserApiFp(this.configuration).changePassword(emailRequest, options)(this.axios, this.basePath);
    }

    /**
     * Get authenticated user profile
     * @summary Get authenticated user profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: any) {
        return UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get the authenticated user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getRoles(options?: any) {
        return UserApiFp(this.configuration).getRoles(options)(this.axios, this.basePath);
    }

    /**
     * Get a list of token names
     * @summary Get a list of token names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listRefreshTokens(options?: any) {
        return UserApiFp(this.configuration).listRefreshTokens(options)(this.axios, this.basePath);
    }

    /**
     * Login a user
     * @summary Login to the platform and get a JWT back
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginDto: LoginDto, options?: any) {
        return UserApiFp(this.configuration).login(loginDto, options)(this.axios, this.basePath);
    }

    /**
     * Sign Up a new user
     * @summary Sign Up to the platform!
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public signup(signUpDto: SignUpDto, options?: any) {
        return UserApiFp(this.configuration).signup(signUpDto, options)(this.axios, this.basePath);
    }

    /**
     * Get refresh token and delete previous one if it exists
     * @summary Get refresh token and delete previous one if it exists
     * @param {CreateTokenDto} createTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public upsertRefreshToken(createTokenDto: CreateTokenDto, options?: any) {
        return UserApiFp(this.configuration).upsertRefreshToken(createTokenDto, options)(this.axios, this.basePath);
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 * @hidden
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options: any = {}): RequestArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling checkUsername.');
            }
            const localVarPath = `/users/check_username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getOneUser.');
            }
            const localVarPath = `/users/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 * @hidden
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).checkUsername(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUserDto> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getOneUser(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicUserDto>> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).listUsers(page, perPage, name, username, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 * @hidden
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Check if a username is already taken by a user or an org
         * @summary Check if a username is already taken
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(username: string, options?: any) {
            return UsersApiFp(configuration).checkUsername(username, options)(axios, basePath);
        },
        /**
         * Get a specific user profile by name
         * @summary Get a specific user profile
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(name: string, options?: any) {
            return UsersApiFp(configuration).getOneUser(name, options)(axios, basePath);
        },
        /**
         * 
         * @summary List Users
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {string} [name] Name of the user to search for
         * @param {string} [username] Username of the user to search for
         * @param {Array<string>} [id] A list of users to search for by their user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any) {
            return UsersApiFp(configuration).listUsers(page, perPage, name, username, id, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Check if a username is already taken by a user or an org
     * @summary Check if a username is already taken
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    checkUsername(username: string, options?: any): AxiosPromise<object>;

    /**
     * Get a specific user profile by name
     * @summary Get a specific user profile
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getOneUser(name: string, options?: any): AxiosPromise<PublicUserDto>;

    /**
     * 
     * @summary List Users
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {string} [name] Name of the user to search for
     * @param {string} [username] Username of the user to search for
     * @param {Array<string>} [id] A list of users to search for by their user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any): AxiosPromise<Array<PublicUserDto>>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Check if a username is already taken by a user or an org
     * @summary Check if a username is already taken
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkUsername(username: string, options?: any) {
        return UsersApiFp(this.configuration).checkUsername(username, options)(this.axios, this.basePath);
    }

    /**
     * Get a specific user profile by name
     * @summary Get a specific user profile
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOneUser(name: string, options?: any) {
        return UsersApiFp(this.configuration).getOneUser(name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List Users
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {string} [name] Name of the user to search for
     * @param {string} [username] Username of the user to search for
     * @param {Array<string>} [id] A list of users to search for by their user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(page?: number, perPage?: number, name?: string, username?: string, id?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).listUsers(page, perPage, name, username, id, options)(this.axios, this.basePath);
    }

}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 * @hidden
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {string} owner 
         * @param {CreateWorkflowDto} createWorkflowDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(owner: string, createWorkflowDto: CreateWorkflowDto, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createWorkflow.');
            }
            // verify required parameter 'createWorkflowDto' is not null or undefined
            if (createWorkflowDto === null || createWorkflowDto === undefined) {
                throw new RequiredError('createWorkflowDto','Required parameter createWorkflowDto was null or undefined when calling createWorkflow.');
            }
            const localVarPath = `/workflows/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createWorkflowDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWorkflowDto !== undefined ? createWorkflowDto : {}) : (createWorkflowDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow (must have `admin` permission)
         * @summary Delete a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteWorkflow.');
            }
            const localVarPath = `/workflows/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowOrgPermission(owner: string, name: string, orgRole: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteWorkflowOrgPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteWorkflowOrgPermission.');
            }
            // verify required parameter 'orgRole' is not null or undefined
            if (orgRole === null || orgRole === undefined) {
                throw new RequiredError('orgRole','Required parameter orgRole was null or undefined when calling deleteWorkflowOrgPermission.');
            }
            const localVarPath = `/workflows/{owner}/{name}/permissions/org/{org_role}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"org_role"}}`, encodeURIComponent(String(orgRole)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTeamPermission(owner: string, name: string, teamName: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteWorkflowTeamPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteWorkflowTeamPermission.');
            }
            // verify required parameter 'teamName' is not null or undefined
            if (teamName === null || teamName === undefined) {
                throw new RequiredError('teamName','Required parameter teamName was null or undefined when calling deleteWorkflowTeamPermission.');
            }
            const localVarPath = `/workflows/{owner}/{name}/permissions/team/{team_name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"team_name"}}`, encodeURIComponent(String(teamName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a workflow by name
         * @summary Get a workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getWorkflow.');
            }
            const localVarPath = `/workflows/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a workflow\'s access permissions (must have `contribute` permission)
         * @summary Get a workflow\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowAccessPermissions(owner: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getWorkflowAccessPermissions.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getWorkflowAccessPermissions.');
            }
            const localVarPath = `/workflows/{owner}/{name}/permissions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search for workflows using query parameters
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per-page'] = perPage;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (owner) {
                localVarQueryParameter['owner'] = owner;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (operator) {
                localVarQueryParameter['operator'] = operator;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a workflow (must have `contribute` permission)
         * @summary Update a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchWorkflow} patchWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(owner: string, name: string, patchWorkflow: PatchWorkflow, options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateWorkflow.');
            }
            // verify required parameter 'patchWorkflow' is not null or undefined
            if (patchWorkflow === null || patchWorkflow === undefined) {
                throw new RequiredError('patchWorkflow','Required parameter patchWorkflow was null or undefined when calling updateWorkflow.');
            }
            const localVarPath = `/workflows/{owner}/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchWorkflow !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWorkflow !== undefined ? patchWorkflow : {}) : (patchWorkflow || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowOrgPermission(owner: string, name: string, orgRole: string, permission: 'admin' | 'contribute' | 'use', options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling upsertWorkflowOrgPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertWorkflowOrgPermission.');
            }
            // verify required parameter 'orgRole' is not null or undefined
            if (orgRole === null || orgRole === undefined) {
                throw new RequiredError('orgRole','Required parameter orgRole was null or undefined when calling upsertWorkflowOrgPermission.');
            }
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new RequiredError('permission','Required parameter permission was null or undefined when calling upsertWorkflowOrgPermission.');
            }
            const localVarPath = `/workflows/{owner}/{name}/permissions/org/{org_role}/{permission}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"org_role"}}`, encodeURIComponent(String(orgRole)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowTeamPermission(owner: string, name: string, teamName: string, permission: 'admin' | 'contribute' | 'use', options: any = {}): RequestArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling upsertWorkflowTeamPermission.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upsertWorkflowTeamPermission.');
            }
            // verify required parameter 'teamName' is not null or undefined
            if (teamName === null || teamName === undefined) {
                throw new RequiredError('teamName','Required parameter teamName was null or undefined when calling upsertWorkflowTeamPermission.');
            }
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new RequiredError('permission','Required parameter permission was null or undefined when calling upsertWorkflowTeamPermission.');
            }
            const localVarPath = `/workflows/{owner}/{name}/permissions/team/{team_name}/{permission}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"team_name"}}`, encodeURIComponent(String(teamName)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 * @hidden
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {string} owner 
         * @param {CreateWorkflowDto} createWorkflowDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(owner: string, createWorkflowDto: CreateWorkflowDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedContent> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).createWorkflow(owner, createWorkflowDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a workflow (must have `admin` permission)
         * @summary Delete a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).deleteWorkflow(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowOrgPermission(owner: string, name: string, orgRole: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).deleteWorkflowOrgPermission(owner, name, orgRole, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTeamPermission(owner: string, name: string, teamName: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).deleteWorkflowTeamPermission(owner, name, teamName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a workflow by name
         * @summary Get a workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).getWorkflow(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a workflow\'s access permissions (must have `contribute` permission)
         * @summary Get a workflow\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowAccessPermissions(owner: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowAccessPolicyDto>> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).getWorkflowAccessPermissions(owner, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * search for workflows using query parameters
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowDto>> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).listWorkflows(page, perPage, id, name, owner, _public, operator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a workflow (must have `contribute` permission)
         * @summary Update a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchWorkflow} patchWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(owner: string, name: string, patchWorkflow: PatchWorkflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).updateWorkflow(owner, name, patchWorkflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowOrgPermission(owner: string, name: string, orgRole: string, permission: 'admin' | 'contribute' | 'use', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).upsertWorkflowOrgPermission(owner, name, orgRole, permission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowTeamPermission(owner: string, name: string, teamName: string, permission: 'admin' | 'contribute' | 'use', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAccepted> {
            const localVarAxiosArgs = WorkflowsApiAxiosParamCreator(configuration).upsertWorkflowTeamPermission(owner, name, teamName, permission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 * @hidden
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new workflow.
         * @summary Create a Workflow
         * @param {string} owner 
         * @param {CreateWorkflowDto} createWorkflowDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(owner: string, createWorkflowDto: CreateWorkflowDto, options?: any) {
            return WorkflowsApiFp(configuration).createWorkflow(owner, createWorkflowDto, options)(axios, basePath);
        },
        /**
         * Delete a workflow (must have `admin` permission)
         * @summary Delete a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(owner: string, name: string, options?: any) {
            return WorkflowsApiFp(configuration).deleteWorkflow(owner, name, options)(axios, basePath);
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowOrgPermission(owner: string, name: string, orgRole: string, options?: any) {
            return WorkflowsApiFp(configuration).deleteWorkflowOrgPermission(owner, name, orgRole, options)(axios, basePath);
        },
        /**
         * Delete a workflow\'s access policy (must have `admin` permission)
         * @summary Remove a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTeamPermission(owner: string, name: string, teamName: string, options?: any) {
            return WorkflowsApiFp(configuration).deleteWorkflowTeamPermission(owner, name, teamName, options)(axios, basePath);
        },
        /**
         * Retrieve a workflow by name
         * @summary Get a workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(owner: string, name: string, options?: any) {
            return WorkflowsApiFp(configuration).getWorkflow(owner, name, options)(axios, basePath);
        },
        /**
         * Retrieve a workflow\'s access permissions (must have `contribute` permission)
         * @summary Get a workflow\'s access permissions
         * @param {string} owner 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowAccessPermissions(owner: string, name: string, options?: any) {
            return WorkflowsApiFp(configuration).getWorkflowAccessPermissions(owner, name, options)(axios, basePath);
        },
        /**
         * search for workflows using query parameters
         * @summary List Workflows
         * @param {number} [page] Page number starting from 1
         * @param {number} [perPage] Number of items per page
         * @param {Array<string>} [id] The ID of a project to search for
         * @param {Array<string>} [name] The account name
         * @param {Array<string>} [owner] Owner of the project
         * @param {boolean} [_public] Boolean check for public/private projects
         * @param {Array<string>} [operator] Name of an operator to search workflows by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
            return WorkflowsApiFp(configuration).listWorkflows(page, perPage, id, name, owner, _public, operator, options)(axios, basePath);
        },
        /**
         * Update a workflow (must have `contribute` permission)
         * @summary Update a Workflow
         * @param {string} owner 
         * @param {string} name 
         * @param {PatchWorkflow} patchWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(owner: string, name: string, patchWorkflow: PatchWorkflow, options?: any) {
            return WorkflowsApiFp(configuration).updateWorkflow(owner, name, patchWorkflow, options)(axios, basePath);
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow org level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} orgRole 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowOrgPermission(owner: string, name: string, orgRole: string, permission: 'admin' | 'contribute' | 'use', options?: any) {
            return WorkflowsApiFp(configuration).upsertWorkflowOrgPermission(owner, name, orgRole, permission, options)(axios, basePath);
        },
        /**
         * Upsert a workflow\'s access policy (must have `admin` permission)
         * @summary Upsert a Workflow team level permission
         * @param {string} owner 
         * @param {string} name 
         * @param {string} teamName 
         * @param {'admin' | 'contribute' | 'use'} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertWorkflowTeamPermission(owner: string, name: string, teamName: string, permission: 'admin' | 'contribute' | 'use', options?: any) {
            return WorkflowsApiFp(configuration).upsertWorkflowTeamPermission(owner, name, teamName, permission, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowsApi - interface
 * @export
 * @interface WorkflowsApi
 */
export interface WorkflowsApiInterface {
    /**
     * Create a new workflow.
     * @summary Create a Workflow
     * @param {string} owner 
     * @param {CreateWorkflowDto} createWorkflowDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    createWorkflow(owner: string, createWorkflowDto: CreateWorkflowDto, options?: any): AxiosPromise<CreatedContent>;

    /**
     * Delete a workflow (must have `admin` permission)
     * @summary Delete a Workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    deleteWorkflow(owner: string, name: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a workflow\'s access policy (must have `admin` permission)
     * @summary Remove a Workflow org level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} orgRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    deleteWorkflowOrgPermission(owner: string, name: string, orgRole: string, options?: any): AxiosPromise<{}>;

    /**
     * Delete a workflow\'s access policy (must have `admin` permission)
     * @summary Remove a Workflow team level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} teamName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    deleteWorkflowTeamPermission(owner: string, name: string, teamName: string, options?: any): AxiosPromise<{}>;

    /**
     * Retrieve a workflow by name
     * @summary Get a workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    getWorkflow(owner: string, name: string, options?: any): AxiosPromise<WorkflowDto>;

    /**
     * Retrieve a workflow\'s access permissions (must have `contribute` permission)
     * @summary Get a workflow\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    getWorkflowAccessPermissions(owner: string, name: string, options?: any): AxiosPromise<Array<WorkflowAccessPolicyDto>>;

    /**
     * search for workflows using query parameters
     * @summary List Workflows
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    listWorkflows(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any): AxiosPromise<Array<WorkflowDto>>;

    /**
     * Update a workflow (must have `contribute` permission)
     * @summary Update a Workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchWorkflow} patchWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    updateWorkflow(owner: string, name: string, patchWorkflow: PatchWorkflow, options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a workflow\'s access policy (must have `admin` permission)
     * @summary Upsert a Workflow org level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} orgRole 
     * @param {'admin' | 'contribute' | 'use'} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    upsertWorkflowOrgPermission(owner: string, name: string, orgRole: string, permission: 'admin' | 'contribute' | 'use', options?: any): AxiosPromise<UpdateAccepted>;

    /**
     * Upsert a workflow\'s access policy (must have `admin` permission)
     * @summary Upsert a Workflow team level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} teamName 
     * @param {'admin' | 'contribute' | 'use'} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiInterface
     */
    upsertWorkflowTeamPermission(owner: string, name: string, teamName: string, permission: 'admin' | 'contribute' | 'use', options?: any): AxiosPromise<UpdateAccepted>;

}

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI implements WorkflowsApiInterface {
    /**
     * Create a new workflow.
     * @summary Create a Workflow
     * @param {string} owner 
     * @param {CreateWorkflowDto} createWorkflowDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflow(owner: string, createWorkflowDto: CreateWorkflowDto, options?: any) {
        return WorkflowsApiFp(this.configuration).createWorkflow(owner, createWorkflowDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete a workflow (must have `admin` permission)
     * @summary Delete a Workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflow(owner: string, name: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflow(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Delete a workflow\'s access policy (must have `admin` permission)
     * @summary Remove a Workflow org level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} orgRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowOrgPermission(owner: string, name: string, orgRole: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowOrgPermission(owner, name, orgRole, options)(this.axios, this.basePath);
    }

    /**
     * Delete a workflow\'s access policy (must have `admin` permission)
     * @summary Remove a Workflow team level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} teamName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowTeamPermission(owner: string, name: string, teamName: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowTeamPermission(owner, name, teamName, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a workflow by name
     * @summary Get a workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflow(owner: string, name: string, options?: any) {
        return WorkflowsApiFp(this.configuration).getWorkflow(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a workflow\'s access permissions (must have `contribute` permission)
     * @summary Get a workflow\'s access permissions
     * @param {string} owner 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowAccessPermissions(owner: string, name: string, options?: any) {
        return WorkflowsApiFp(this.configuration).getWorkflowAccessPermissions(owner, name, options)(this.axios, this.basePath);
    }

    /**
     * search for workflows using query parameters
     * @summary List Workflows
     * @param {number} [page] Page number starting from 1
     * @param {number} [perPage] Number of items per page
     * @param {Array<string>} [id] The ID of a project to search for
     * @param {Array<string>} [name] The account name
     * @param {Array<string>} [owner] Owner of the project
     * @param {boolean} [_public] Boolean check for public/private projects
     * @param {Array<string>} [operator] Name of an operator to search workflows by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflows(page?: number, perPage?: number, id?: Array<string>, name?: Array<string>, owner?: Array<string>, _public?: boolean, operator?: Array<string>, options?: any) {
        return WorkflowsApiFp(this.configuration).listWorkflows(page, perPage, id, name, owner, _public, operator, options)(this.axios, this.basePath);
    }

    /**
     * Update a workflow (must have `contribute` permission)
     * @summary Update a Workflow
     * @param {string} owner 
     * @param {string} name 
     * @param {PatchWorkflow} patchWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflow(owner: string, name: string, patchWorkflow: PatchWorkflow, options?: any) {
        return WorkflowsApiFp(this.configuration).updateWorkflow(owner, name, patchWorkflow, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a workflow\'s access policy (must have `admin` permission)
     * @summary Upsert a Workflow org level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} orgRole 
     * @param {'admin' | 'contribute' | 'use'} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public upsertWorkflowOrgPermission(owner: string, name: string, orgRole: string, permission: 'admin' | 'contribute' | 'use', options?: any) {
        return WorkflowsApiFp(this.configuration).upsertWorkflowOrgPermission(owner, name, orgRole, permission, options)(this.axios, this.basePath);
    }

    /**
     * Upsert a workflow\'s access policy (must have `admin` permission)
     * @summary Upsert a Workflow team level permission
     * @param {string} owner 
     * @param {string} name 
     * @param {string} teamName 
     * @param {'admin' | 'contribute' | 'use'} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public upsertWorkflowTeamPermission(owner: string, name: string, teamName: string, permission: 'admin' | 'contribute' | 'use', options?: any) {
        return WorkflowsApiFp(this.configuration).upsertWorkflowTeamPermission(owner, name, teamName, permission, options)(this.axios, this.basePath);
    }

}


